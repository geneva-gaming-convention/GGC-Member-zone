<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>c3.min.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
</script>

<script src="../../../js/jquery.js"></script>
<script src="../../../js/darkfish.js"></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../../Capfile.html">Capfile</a>
  
    <li><a href="../../../Gemfile.html">Gemfile</a>
  
    <li><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../../README_rdoc.html">README</a>
  
    <li><a href="../../../Rakefile.html">Rakefile</a>
  
    <li><a href="../../../app/assets/images/fb_svg.html">fb.svg</a>
  
    <li><a href="../../../app/assets/images/gh_svg.html">gh.svg</a>
  
    <li><a href="../../../app/assets/images/tw_svg.html">tw.svg</a>
  
    <li><a href="../../../app/assets/images/yt_svg.html">yt.svg</a>
  
    <li><a href="../../../app/assets/javascripts/application_js.html">application.js</a>
  
    <li><a href="../../../app/assets/javascripts/event_resources_js.html">event_resources.js</a>
  
    <li><a href="../../../app/assets/javascripts/events_js.html">events.js</a>
  
    <li><a href="../../../app/assets/javascripts/global_js.html">global.js</a>
  
    <li><a href="../../../app/assets/javascripts/menu_lat_js.html">menu_lat.js</a>
  
    <li><a href="../../../app/assets/javascripts/registration_js.html">registration.js</a>
  
    <li><a href="../../../app/assets/javascripts/reset_password_coffee.html">reset_password.coffee</a>
  
    <li><a href="../../../app/assets/javascripts/sessions_js.html">sessions.js</a>
  
    <li><a href="../../../app/assets/javascripts/static_coffee.html">static.coffee</a>
  
    <li><a href="../../../app/assets/javascripts/users_js.html">users.js</a>
  
    <li><a href="../../../app/assets/stylesheets/address_scss.html">address.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/application_scss.html">application.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/event_resources_scss.html">event_resources.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/events_scss.html">events.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/global_scss.html">global.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/registration_scss.html">registration.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/reset_password_scss.html">reset_password.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/sessions_scss.html">sessions.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/static_scss.html">static.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/users_scss.html">users.scss</a>
  
    <li><a href="../../../app/assets/stylesheets/welcome_scss.html">welcome.scss</a>
  
    <li><a href="../../../config_ru.html">config.ru</a>
  
    <li><a href="../../../lib/assets/javascript/c3_min_js.html">c3.min.js</a>
  
    <li><a href="../../../lib/assets/javascript/d3_min_js.html">d3.min.js</a>
  
    <li><a href="../../../lib/assets/javascript/jquery_matchHeight-min_js.html">jquery.matchHeight-min.js</a>
  
    <li><a href="../../../log/capistrano_log.html">capistrano.log</a>
  
    <li><a href="../../../log/development_log.html">development.log</a>
  
    <li><a href="../../../log/development_conflict-20170123-082632_log.html">development_conflict-20170123-082632.log</a>
  
    <li><a href="../../../log/test_log.html">test.log</a>
  
    <li><a href="../../../public/422_html.html">422.html</a>
  
    <li><a href="../../../public/500_html.html">500.html</a>
  
    <li><a href="../../../public/favicon_ico.html">favicon.ico</a>
  
    <li><a href="../../../public/robots_txt.html">robots</a>
  
    <li><a href="../../../tmp/pids/server_pid.html">server.pid</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page lib/assets/javascript/c3.min.js">

<p>!function(a) {</p>

<pre>&quot;use strict&quot;;
function b(a) {
    this.owner = a
}
function c(a, b) {
    if (Object.create)
    b.prototype = Object.create(a.prototype);
    else {
        var c = function() {};
        c.prototype = a.prototype, b.prototype = new c
    }
    return b.prototype.constructor = b, b
}
function d(a) {
    var b = this.internal = new e(this);
    b.loadConfig(a), b.beforeInit(a), b.init(), b.afterInit(a), function c(a, b, d) {
        Object.keys(a).forEach(function(e) {
            b[e] = a[e].bind(d), Object.keys(a[e]).length &gt; 0 &amp;&amp; c(a[e], b[e], d)
        })
    }(h, this, this)
}
function e(b) {
    var c = this;
    c.d3 = a.d3 ? a.d3 : &quot;undefined&quot; != typeof require ? require(&quot;d3&quot;) : void 0, c.api = b, c.config = c.getDefaultConfig(), c.data = {}, c.cache = {}, c.axes = {}
}
function f(a) {
    b.call(this, a)
}
function g(a, b) {
    function c(a, b) {
        a.attr(&quot;transform&quot;, function(a) {
            return &quot;translate(&quot; + Math.ceil(b(a) + u) + &quot;, 0)&quot;
        })
    }
    function d(a, b) {
        a.attr(&quot;transform&quot;, function(a) {
            return &quot;translate(0,&quot; + Math.ceil(b(a)) + &quot;)&quot;
        })
    }
    function e(a) {
        var b = a[0],
        c = a[a.length - 1];
        return c &gt; b ? [b, c] : [c, b]
    }
    function f(a) {
        var b,
        c,
        d = [];
        if (a.ticks)
        return a.ticks.apply(a, n);
        for (c = a.domain(), b = Math.ceil(c[0]); b &lt; c[1]; b++)
        d.push(b);
        return d.length &gt; 0 &amp;&amp; d[0] &gt; 0 &amp;&amp; d.unshift(d[0] - (d[1] - d[0])), d
    }
    function g() {
        var a,
        c = p.copy();
        return b.isCategory &amp;&amp; (a = p.domain(), c.domain([a[0], a[1] - 1])), c
    }
    function h(a) {
        var b = m ? m(a) : a;
        return &quot;undefined&quot; != typeof b ? b : &quot;&quot;
    }
    function i(a) {
        if (A)
        return A;
        var b = {
            h: 11.5,
            w: 5.5
        };
        return a.select(&quot;text&quot;).text(h).each(function(a) {
            var c = this.getBoundingClientRect(),
            d = h(a),
            e = c.height,
            f = d ? c.width / d.length : void 0;
            e &amp;&amp; f &amp;&amp; (b.h = e, b.w = f)
        }).text(&quot;&quot;), A = b, b
    }
    function j(c) {
        return b.withoutTransition ? c : a.transition(c)
    }
    function k(m) {
        m.each(function() {
            function m(a, c) {
                function d(a, b) {
                    f = void 0;
                    for (var h = 1; h &lt; b.length; h++)
                    if (&quot; &quot; === b.charAt(h) &amp;&amp; (f = h), e = b.substr(0, h + 1), g = U.w * e.length, g &gt; c)
                    return d(a.concat(b.substr(0, f ? f : h)), b.slice(f ? f + 1 : h));
                    return a.concat(b)
                }
                var e,
                f,
                g,
                i = h(a),
                j = [];
                return &quot;[object Array]&quot; === Object.prototype.toString.call(i) ? i : ((!c || 0 &gt;= c) &amp;&amp; (c = X ? 95 : b.isCategory ? Math.ceil(F(G[1]) - F(G[0])) - 12 : 110), d(j, i + &quot;&quot;))
            }
            function n(a, b) {
                var c = U.h;
                return 0 === b &amp;&amp; (c = &quot;left&quot; === q || &quot;right&quot; === q ? -((V[a.index] - 1) * (U.h / 2) - 3) : &quot;.71em&quot;), c
            }
            function v(a) {
                var b = p(a) + (o ? 0 : u);
                return L[0] &lt; b &amp;&amp; b &lt; L[1] ? r : 0
            }
            function w(a) {
                return a ? a &gt; 0 ? &quot;start&quot; : &quot;end&quot; : &quot;middle&quot;
            }
            function x(a) {
                return a ? &quot;rotate(&quot; + a + &quot;)&quot; : &quot;&quot;
            }
            function y(a) {
                return a ? 8 * Math.sin(Math.PI * (a / 180)) : 0
            }
            function z(a) {
                return a ? 11.5 - 2.5 * (a / 15) * (a &gt; 0 ? 1 : -1) : W
            }
            var A,
            B,
            C,
            D = k.g = a.select(this),
            E = this.__chart__ || p,
            F = this.__chart__ = g(),
            G = t ? t : f(F),
            H = D.selectAll(&quot;.tick&quot;).data(G, F),
            I = H.enter().insert(&quot;g&quot;, &quot;.domain&quot;).attr(&quot;class&quot;, &quot;tick&quot;).style(&quot;opacity&quot;, 1e-6),
            J = H.exit().remove(),
            K = j(H).style(&quot;opacity&quot;, 1),
            L = p.rangeExtent ? p.rangeExtent() : e(p.range()),
            M = D.selectAll(&quot;.domain&quot;).data([0]),
            N = (M.enter().append(&quot;path&quot;).attr(&quot;class&quot;, &quot;domain&quot;), j(M));
            I.append(&quot;line&quot;), I.append(&quot;text&quot;);
            var O = I.select(&quot;line&quot;),
            P = K.select(&quot;line&quot;),
            Q = I.select(&quot;text&quot;),
            R = K.select(&quot;text&quot;);
            b.isCategory ? (u = Math.ceil((F(1) - F(0)) / 2), B = o ? 0 : u, C = o ? u : 0) : u = B = 0;
            var S,
            T,
            U = i(D.select(&quot;.tick&quot;)),
            V = [],
            W = Math.max(r, 0) + s,
            X = &quot;left&quot; === q || &quot;right&quot; === q;
            S = H.select(&quot;text&quot;), T = S.selectAll(&quot;tspan&quot;).data(function(a, c) {
                var d = b.tickMultiline ? m(a, b.tickWidth) : [].concat(h(a));
                return V[c] = d.length, d.map(function(a) {
                    return {
                        index: c,
                        splitted: a
                    }
                })
            }), T.enter().append(&quot;tspan&quot;), T.exit().remove(), T.text(function(a) {
                return a.splitted
            });
            var Y = b.tickTextRotate;
            switch (q) {
                case &quot;bottom&quot;:
                A = c, O.attr(&quot;y2&quot;, r), Q.attr(&quot;y&quot;, W), P.attr(&quot;x1&quot;, B).attr(&quot;x2&quot;, B).attr(&quot;y2&quot;, v), R.attr(&quot;x&quot;, 0).attr(&quot;y&quot;, z(Y)).style(&quot;text-anchor&quot;, w(Y)).attr(&quot;transform&quot;, x(Y)), T.attr(&quot;x&quot;, 0).attr(&quot;dy&quot;, n).attr(&quot;dx&quot;, y(Y)), N.attr(&quot;d&quot;, &quot;M&quot; + L[0] + &quot;,&quot; + l + &quot;V0H&quot; + L[1] + &quot;V&quot; + l);
                break;
                case &quot;top&quot;:
                A = c, O.attr(&quot;y2&quot;, -r), Q.attr(&quot;y&quot;, -W), P.attr(&quot;x2&quot;, 0).attr(&quot;y2&quot;, -r), R.attr(&quot;x&quot;, 0).attr(&quot;y&quot;, -W), S.style(&quot;text-anchor&quot;, &quot;middle&quot;), T.attr(&quot;x&quot;, 0).attr(&quot;dy&quot;, &quot;0em&quot;), N.attr(&quot;d&quot;, &quot;M&quot; + L[0] + &quot;,&quot; + -l + &quot;V0H&quot; + L[1] + &quot;V&quot; + -l);
                break;
                case &quot;left&quot;:
                A = d, O.attr(&quot;x2&quot;, -r), Q.attr(&quot;x&quot;, -W), P.attr(&quot;x2&quot;, -r).attr(&quot;y1&quot;, C).attr(&quot;y2&quot;, C), R.attr(&quot;x&quot;, -W).attr(&quot;y&quot;, u), S.style(&quot;text-anchor&quot;, &quot;end&quot;), T.attr(&quot;x&quot;, -W).attr(&quot;dy&quot;, n), N.attr(&quot;d&quot;, &quot;M&quot; + -l + &quot;,&quot; + L[0] + &quot;H0V&quot; + L[1] + &quot;H&quot; + -l);
                break;
                case &quot;right&quot;:
                A = d, O.attr(&quot;x2&quot;, r), Q.attr(&quot;x&quot;, W), P.attr(&quot;x2&quot;, r).attr(&quot;y2&quot;, 0), R.attr(&quot;x&quot;, W).attr(&quot;y&quot;, 0), S.style(&quot;text-anchor&quot;, &quot;start&quot;), T.attr(&quot;x&quot;, W).attr(&quot;dy&quot;, n), N.attr(&quot;d&quot;, &quot;M&quot; + l + &quot;,&quot; + L[0] + &quot;H0V&quot; + L[1] + &quot;H&quot; + l)
            }
            if (F.rangeBand) {
                var Z = F,
                $ = Z.rangeBand() / 2;
                E = F = function(a) {
                    return Z(a) + $
                }
            } else
            E.rangeBand ? E = F : J.call(A, F);
            I.call(A, E), K.call(A, F)
        })
    }
    var l,
    m,
    n,
    o,
    p = a.scale.linear(),
    q = &quot;bottom&quot;,
    r = 6,
    s = 3,
    t = null,
    u = 0,
    v = !0;
    return b = b || {}, l = b.withOuterTick ? 6 : 0, k.scale = function(a) {
        return arguments.length ? (p = a, k) : p
    }, k.orient = function(a) {
        return arguments.length ? (q = a in {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
        } ? a + &quot;&quot; : &quot;bottom&quot;, k) : q
    }, k.tickFormat = function(a) {
        return arguments.length ? (m = a, k) : m
    }, k.tickCentered = function(a) {
        return arguments.length ? (o = a, k) : o
    }, k.tickOffset = function() {
        return u
    }, k.tickInterval = function() {
        var a,
        c;
        return b.isCategory ? a = 2 * u : (c = k.g.select(&quot;path.domain&quot;).node().getTotalLength() - 2 * l, a = c / k.g.selectAll(&quot;line&quot;).size()), a === 1 / 0 ? 0 : a
    }, k.ticks = function() {
        return arguments.length ? (n = arguments, k) : n
    }, k.tickCulling = function(a) {
        return arguments.length ? (v = a, k) : v
    }, k.tickValues = function(a) {
        if (&quot;function&quot; == typeof a)
        t = function() {
            return a(p.domain())
        };
        else {
            if (!arguments.length)
            return t;
            t = a
        }
        return k
    }, k
}
var h,
i,
j,
k = {
    version: &quot;0.4.11&quot;
};
k.generate = function(a) {
    return new d(a)
}, k.chart = {
    fn: d.prototype,
    internal: {
        fn: e.prototype,
        axis: {
            fn: f.prototype
        }
    }
}, h = k.chart.fn, i = k.chart.internal.fn, j = k.chart.internal.axis.fn, i.beforeInit = function() {}, i.afterInit = function() {}, i.init = function() {
    var a = this,
    b = a.config;
    if (a.initParams(), b.data_url)
    a.convertUrlToData(b.data_url, b.data_mimeType, b.data_headers, b.data_keys, a.initWithData);
    else if (b.data_json)
    a.initWithData(a.convertJsonToData(b.data_json, b.data_keys));
    else if (b.data_rows)
    a.initWithData(a.convertRowsToData(b.data_rows));
    else {
        if (!b.data_columns)
        throw Error(&quot;url or json or rows or columns is required.&quot;);
        a.initWithData(a.convertColumnsToData(b.data_columns))
    }
}, i.initParams = function() {
    var a = this,
    b = a.d3,
    c = a.config;
    a.clipId = &quot;c3-&quot; + +new Date + &quot;-clip&quot;, a.clipIdForXAxis = a.clipId + &quot;-xaxis&quot;, a.clipIdForYAxis = a.clipId + &quot;-yaxis&quot;, a.clipIdForGrid = a.clipId + &quot;-grid&quot;, a.clipIdForSubchart = a.clipId + &quot;-subchart&quot;, a.clipPath = a.getClipPath(a.clipId), a.clipPathForXAxis = a.getClipPath(a.clipIdForXAxis), a.clipPathForYAxis = a.getClipPath(a.clipIdForYAxis), a.clipPathForGrid = a.getClipPath(a.clipIdForGrid), a.clipPathForSubchart = a.getClipPath(a.clipIdForSubchart), a.dragStart = null, a.dragging = !1, a.flowing = !1, a.cancelClick = !1, a.mouseover = !1, a.transiting = !1, a.color = a.generateColor(), a.levelColor = a.generateLevelColor(), a.dataTimeFormat = c.data_xLocaltime ? b.time.format : b.time.format.utc, a.axisTimeFormat = c.axis_x_localtime ? b.time.format : b.time.format.utc, a.defaultAxisTimeFormat = a.axisTimeFormat.multi([[&quot;.%L&quot;, function(a) {
        return a.getMilliseconds()
    }], [&quot;:%S&quot;, function(a) {
        return a.getSeconds()
    }], [&quot;%I:%M&quot;, function(a) {
        return a.getMinutes()
    }], [&quot;%I %p&quot;, function(a) {
        return a.getHours()
    }], [&quot;%-m/%-d&quot;, function(a) {
        return a.getDay() &amp;&amp; 1 !== a.getDate()
    }], [&quot;%-m/%-d&quot;, function(a) {
        return 1 !== a.getDate()
    }], [&quot;%-m/%-d&quot;, function(a) {
        return a.getMonth()
    }], [&quot;%Y/%-m/%-d&quot;, function() {
        return !0
    }]]), a.hiddenTargetIds = [], a.hiddenLegendIds = [], a.focusedTargetIds = [], a.defocusedTargetIds = [], a.xOrient = c.axis_rotated ? &quot;left&quot; : &quot;bottom&quot;, a.yOrient = c.axis_rotated ? c.axis_y_inner ? &quot;top&quot; : &quot;bottom&quot; : c.axis_y_inner ? &quot;right&quot; : &quot;left&quot;, a.y2Orient = c.axis_rotated ? c.axis_y2_inner ? &quot;bottom&quot; : &quot;top&quot; : c.axis_y2_inner ? &quot;left&quot; : &quot;right&quot;, a.subXOrient = c.axis_rotated ? &quot;left&quot; : &quot;bottom&quot;, a.isLegendRight = &quot;right&quot; === c.legend_position, a.isLegendInset = &quot;inset&quot; === c.legend_position, a.isLegendTop = &quot;top-left&quot; === c.legend_inset_anchor || &quot;top-right&quot; === c.legend_inset_anchor, a.isLegendLeft = &quot;top-left&quot; === c.legend_inset_anchor || &quot;bottom-left&quot; === c.legend_inset_anchor, a.legendStep = 0, a.legendItemWidth = 0, a.legendItemHeight = 0, a.currentMaxTickWidths = {
        x: 0,
        y: 0,
        y2: 0
    }, a.rotated_padding_left = 30, a.rotated_padding_right = c.axis_rotated &amp;&amp; !c.axis_x_show ? 0 : 30, a.rotated_padding_top = 5, a.withoutFadeIn = {}, a.intervalForObserveInserted = void 0, a.axes.subx = b.selectAll([])
}, i.initChartElements = function() {
    this.initBar &amp;&amp; this.initBar(), this.initLine &amp;&amp; this.initLine(), this.initArc &amp;&amp; this.initArc(), this.initGauge &amp;&amp; this.initGauge(), this.initText &amp;&amp; this.initText()
}, i.initWithData = function(a) {
    var b,
    c,
    d = this,
    e = d.d3,
    g = d.config,
    h = !0;
    d.axis = new f(d), d.initPie &amp;&amp; d.initPie(), d.initBrush &amp;&amp; d.initBrush(), d.initZoom &amp;&amp; d.initZoom(), g.bindto ? &quot;function&quot; == typeof g.bindto.node ? d.selectChart = g.bindto : d.selectChart = e.select(g.bindto) : d.selectChart = e.selectAll([]), d.selectChart.empty() &amp;&amp; (d.selectChart = e.select(document.createElement(&quot;div&quot;)).style(&quot;opacity&quot;, 0), d.observeInserted(d.selectChart), h = !1), d.selectChart.html(&quot;&quot;).classed(&quot;c3&quot;, !0), d.data.xs = {}, d.data.targets = d.convertDataToTargets(a), g.data_filter &amp;&amp; (d.data.targets = d.data.targets.filter(g.data_filter)), g.data_hide &amp;&amp; d.addHiddenTargetIds(g.data_hide === !0 ? d.mapToIds(d.data.targets) : g.data_hide), g.legend_hide &amp;&amp; d.addHiddenLegendIds(g.legend_hide === !0 ? d.mapToIds(d.data.targets) : g.legend_hide), d.hasType(&quot;gauge&quot;) &amp;&amp; (g.legend_show = !1), d.updateSizes(), d.updateScales(), d.x.domain(e.extent(d.getXDomain(d.data.targets))), d.y.domain(d.getYDomain(d.data.targets, &quot;y&quot;)), d.y2.domain(d.getYDomain(d.data.targets, &quot;y2&quot;)), d.subX.domain(d.x.domain()), d.subY.domain(d.y.domain()), d.subY2.domain(d.y2.domain()), d.orgXDomain = d.x.domain(), d.brush &amp;&amp; d.brush.scale(d.subX), g.zoom_enabled &amp;&amp; d.zoom.scale(d.x), d.svg = d.selectChart.append(&quot;svg&quot;).style(&quot;overflow&quot;, &quot;hidden&quot;).on(&quot;mouseenter&quot;, function() {
        return g.onmouseover.call(d)
    }).on(&quot;mouseleave&quot;, function() {
        return g.onmouseout.call(d)
    }), d.config.svg_classname &amp;&amp; d.svg.attr(&quot;class&quot;, d.config.svg_classname), b = d.svg.append(&quot;defs&quot;), d.clipChart = d.appendClip(b, d.clipId), d.clipXAxis = d.appendClip(b, d.clipIdForXAxis), d.clipYAxis = d.appendClip(b, d.clipIdForYAxis), d.clipGrid = d.appendClip(b, d.clipIdForGrid), d.clipSubchart = d.appendClip(b, d.clipIdForSubchart), d.updateSvgSize(), c = d.main = d.svg.append(&quot;g&quot;).attr(&quot;transform&quot;, d.getTranslate(&quot;main&quot;)), d.initSubchart &amp;&amp; d.initSubchart(), d.initTooltip &amp;&amp; d.initTooltip(), d.initLegend &amp;&amp; d.initLegend(), d.initTitle &amp;&amp; d.initTitle(), c.append(&quot;text&quot;).attr(&quot;class&quot;, l.text + &quot; &quot; + l.empty).attr(&quot;text-anchor&quot;, &quot;middle&quot;).attr(&quot;dominant-baseline&quot;, &quot;middle&quot;), d.initRegion(), d.initGrid(), c.append(&quot;g&quot;).attr(&quot;clip-path&quot;, d.clipPath).attr(&quot;class&quot;, l.chart), g.grid_lines_front &amp;&amp; d.initGridLines(), d.initEventRect(), d.initChartElements(), c.insert(&quot;rect&quot;, g.zoom_privileged ? null : &quot;g.&quot; + l.regions).attr(&quot;class&quot;, l.zoomRect).attr(&quot;width&quot;, d.width).attr(&quot;height&quot;, d.height).style(&quot;opacity&quot;, 0).on(&quot;dblclick.zoom&quot;, null), g.axis_x_extent &amp;&amp; d.brush.extent(d.getDefaultExtent()), d.axis.init(), d.updateTargets(d.data.targets), h &amp;&amp; (d.updateDimension(), d.config.oninit.call(d), d.redraw({
        withTransition: !1,
        withTransform: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withTransitionForAxis: !1
    })), d.bindResize(), d.api.element = d.selectChart.node()
}, i.smoothLines = function(a, b) {
    var c = this;
    &quot;grid&quot; === b &amp;&amp; a.each(function() {
        var a = c.d3.select(this),
        b = a.attr(&quot;x1&quot;),
        d = a.attr(&quot;x2&quot;),
        e = a.attr(&quot;y1&quot;),
        f = a.attr(&quot;y2&quot;);
        a.attr({
            x1: Math.ceil(b),
            x2: Math.ceil(d),
            y1: Math.ceil(e),
            y2: Math.ceil(f)
        })
    })
}, i.updateSizes = function() {
    var a = this,
    b = a.config,
    c = a.legend ? a.getLegendHeight() : 0,
    d = a.legend ? a.getLegendWidth() : 0,
    e = a.isLegendRight || a.isLegendInset ? 0 : c,
    f = a.hasArcType(),
    g = b.axis_rotated || f ? 0 : a.getHorizontalAxisHeight(&quot;x&quot;),
    h = b.subchart_show &amp;&amp; !f ? b.subchart_size_height + g : 0;
    a.currentWidth = a.getCurrentWidth(), a.currentHeight = a.getCurrentHeight(), a.margin = b.axis_rotated ? {
        top: a.getHorizontalAxisHeight(&quot;y2&quot;) + a.getCurrentPaddingTop(),
        right: f ? 0 : a.getCurrentPaddingRight(),
        bottom: a.getHorizontalAxisHeight(&quot;y&quot;) + e + a.getCurrentPaddingBottom(),
        left: h + (f ? 0 : a.getCurrentPaddingLeft())
    } : {
        top: 4 + a.getCurrentPaddingTop(),
        right: f ? 0 : a.getCurrentPaddingRight(),
        bottom: g + h + e + a.getCurrentPaddingBottom(),
        left: f ? 0 : a.getCurrentPaddingLeft()
    }, a.margin2 = b.axis_rotated ? {
        top: a.margin.top,
        right: NaN,
        bottom: 20 + e,
        left: a.rotated_padding_left
    } : {
        top: a.currentHeight - h - e,
        right: NaN,
        bottom: g + e,
        left: a.margin.left
    }, a.margin3 = {
        top: 0,
        right: NaN,
        bottom: 0,
        left: 0
    }, a.updateSizeForLegend &amp;&amp; a.updateSizeForLegend(c, d), a.width = a.currentWidth - a.margin.left - a.margin.right, a.height = a.currentHeight - a.margin.top - a.margin.bottom, a.width &lt; 0 &amp;&amp; (a.width = 0), a.height &lt; 0 &amp;&amp; (a.height = 0), a.width2 = b.axis_rotated ? a.margin.left - a.rotated_padding_left - a.rotated_padding_right : a.width, a.height2 = b.axis_rotated ? a.height : a.currentHeight - a.margin2.top - a.margin2.bottom, a.width2 &lt; 0 &amp;&amp; (a.width2 = 0), a.height2 &lt; 0 &amp;&amp; (a.height2 = 0), a.arcWidth = a.width - (a.isLegendRight ? d + 10 : 0), a.arcHeight = a.height - (a.isLegendRight ? 0 : 10), a.hasType(&quot;gauge&quot;) &amp;&amp; !b.gauge_fullCircle &amp;&amp; (a.arcHeight += a.height - a.getGaugeLabelHeight()), a.updateRadius &amp;&amp; a.updateRadius(), a.isLegendRight &amp;&amp; f &amp;&amp; (a.margin3.left = a.arcWidth / 2 + 1.1 * a.radiusExpanded)
}, i.updateTargets = function(a) {
    var b = this;
    b.updateTargetsForText(a), b.updateTargetsForBar(a), b.updateTargetsForLine(a), b.hasArcType() &amp;&amp; b.updateTargetsForArc &amp;&amp; b.updateTargetsForArc(a), b.updateTargetsForSubchart &amp;&amp; b.updateTargetsForSubchart(a), b.showTargets()
}, i.showTargets = function() {
    var a = this;
    a.svg.selectAll(&quot;.&quot; + l.target).filter(function(b) {
        return a.isTargetToShow(b.id)
    }).transition().duration(a.config.transition_duration).style(&quot;opacity&quot;, 1)
}, i.redraw = function(a, b) {
    var c,
    d,
    e,
    f,
    g,
    h,
    i,
    j,
    k,
    m,
    n,
    o,
    p,
    q,
    r,
    s,
    t,
    u,
    v,
    x,
    y,
    z,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H = this,
    I = H.main,
    J = H.d3,
    K = H.config,
    L = H.getShapeIndices(H.isAreaType),
    M = H.getShapeIndices(H.isBarType),
    N = H.getShapeIndices(H.isLineType),
    O = H.hasArcType(),
    P = H.filterTargetsToShow(H.data.targets),
    Q = H.xv.bind(H);
    if (a = a || {}, c = w(a, &quot;withY&quot;, !0), d = w(a, &quot;withSubchart&quot;, !0), e = w(a, &quot;withTransition&quot;, !0), h = w(a, &quot;withTransform&quot;, !1), i = w(a, &quot;withUpdateXDomain&quot;, !1), j = w(a, &quot;withUpdateOrgXDomain&quot;, !1), k = w(a, &quot;withTrimXDomain&quot;, !0), p = w(a, &quot;withUpdateXAxis&quot;, i), m = w(a, &quot;withLegend&quot;, !1), n = w(a, &quot;withEventRect&quot;, !0), o = w(a, &quot;withDimension&quot;, !0), f = w(a, &quot;withTransitionForExit&quot;, e), g = w(a, &quot;withTransitionForAxis&quot;, e), v = e ? K.transition_duration : 0, x = f ? v : 0, y = g ? v : 0, b = b || H.axis.generateTransitions(y), m &amp;&amp; K.legend_show ? H.updateLegend(H.mapToIds(H.data.targets), a, b) : o &amp;&amp; H.updateDimension(!0), H.isCategorized() &amp;&amp; 0 === P.length &amp;&amp; H.x.domain([0, H.axes.x.selectAll(&quot;.tick&quot;).size()]), P.length ? (H.updateXDomain(P, i, j, k), K.axis_x_tick_values || (B = H.axis.updateXAxisTickValues(P))) : (H.xAxis.tickValues([]), H.subXAxis.tickValues([])), K.zoom_rescale &amp;&amp; !a.flow &amp;&amp; (E = H.x.orgDomain()), H.y.domain(H.getYDomain(P, &quot;y&quot;, E)), H.y2.domain(H.getYDomain(P, &quot;y2&quot;, E)), !K.axis_y_tick_values &amp;&amp; K.axis_y_tick_count &amp;&amp; H.yAxis.tickValues(H.axis.generateTickValues(H.y.domain(), K.axis_y_tick_count)), !K.axis_y2_tick_values &amp;&amp; K.axis_y2_tick_count &amp;&amp; H.y2Axis.tickValues(H.axis.generateTickValues(H.y2.domain(), K.axis_y2_tick_count)), H.axis.redraw(b, O), H.axis.updateLabels(e), (i || p) &amp;&amp; P.length)
    if (K.axis_x_tick_culling &amp;&amp; B) {
        for (C = 1; C &lt; B.length; C++)
        if (B.length / C &lt; K.axis_x_tick_culling_max) {
            D = C;
            break
        }
        H.svg.selectAll(&quot;.&quot; + l.axisX + &quot; .tick text&quot;).each(function(a) {
            var b = B.indexOf(a);
            b &gt;= 0 &amp;&amp; J.select(this).style(&quot;display&quot;, b % D ? &quot;none&quot; : &quot;block&quot;)
        })
    } else
    H.svg.selectAll(&quot;.&quot; + l.axisX + &quot; .tick text&quot;).style(&quot;display&quot;, &quot;block&quot;);
    q = H.generateDrawArea ? H.generateDrawArea(L, !1) : void 0, r = H.generateDrawBar ? H.generateDrawBar(M) : void 0, s = H.generateDrawLine ? H.generateDrawLine(N, !1) : void 0, t = H.generateXYForText(L, M, N, !0), u = H.generateXYForText(L, M, N, !1), c &amp;&amp; (H.subY.domain(H.getYDomain(P, &quot;y&quot;)), H.subY2.domain(H.getYDomain(P, &quot;y2&quot;))), H.updateXgridFocus(), I.select(&quot;text.&quot; + l.text + &quot;.&quot; + l.empty).attr(&quot;x&quot;, H.width / 2).attr(&quot;y&quot;, H.height / 2).text(K.data_empty_label_text).transition().style(&quot;opacity&quot;, P.length ? 0 : 1), H.updateGrid(v), H.updateRegion(v), H.updateBar(x), H.updateLine(x), H.updateArea(x), H.updateCircle(), H.hasDataLabel() &amp;&amp; H.updateText(x), H.redrawTitle &amp;&amp; H.redrawTitle(), H.redrawArc &amp;&amp; H.redrawArc(v, x, h), H.redrawSubchart &amp;&amp; H.redrawSubchart(d, b, v, x, L, M, N), I.selectAll(&quot;.&quot; + l.selectedCircles).filter(H.isBarType.bind(H)).selectAll(&quot;circle&quot;).remove(), K.interaction_enabled &amp;&amp; !a.flow &amp;&amp; n &amp;&amp; (H.redrawEventRect(), H.updateZoom &amp;&amp; H.updateZoom()), H.updateCircleY(), F = (H.config.axis_rotated ? H.circleY : H.circleX).bind(H), G = (H.config.axis_rotated ? H.circleX : H.circleY).bind(H), a.flow &amp;&amp; (A = H.generateFlow({
        targets: P,
        flow: a.flow,
        duration: a.flow.duration,
        drawBar: r,
        drawLine: s,
        drawArea: q,
        cx: F,
        cy: G,
        xv: Q,
        xForText: t,
        yForText: u
    })), (v || A) &amp;&amp; H.isTabVisible() ? J.transition().duration(v).each(function() {
        var b = [];
        [H.redrawBar(r, !0), H.redrawLine(s, !0), H.redrawArea(q, !0), H.redrawCircle(F, G, !0), H.redrawText(t, u, a.flow, !0), H.redrawRegion(!0), H.redrawGrid(!0)].forEach(function(a) {
            a.forEach(function(a) {
                b.push(a)
            })
        }), z = H.generateWait(), b.forEach(function(a) {
            z.add(a)
        })
    }).call(z, function() {
        A &amp;&amp; A(), K.onrendered &amp;&amp; K.onrendered.call(H)
    }) : (H.redrawBar(r), H.redrawLine(s), H.redrawArea(q), H.redrawCircle(F, G), H.redrawText(t, u, a.flow), H.redrawRegion(), H.redrawGrid(), K.onrendered &amp;&amp; K.onrendered.call(H)), H.mapToIds(H.data.targets).forEach(function(a) {
        H.withoutFadeIn[a] = !0
    })
}, i.updateAndRedraw = function(a) {
    var b,
    c = this,
    d = c.config;
    a = a || {}, a.withTransition = w(a, &quot;withTransition&quot;, !0), a.withTransform = w(a, &quot;withTransform&quot;, !1), a.withLegend = w(a, &quot;withLegend&quot;, !1), a.withUpdateXDomain = !0, a.withUpdateOrgXDomain = !0, a.withTransitionForExit = !1, a.withTransitionForTransform = w(a, &quot;withTransitionForTransform&quot;, a.withTransition), c.updateSizes(), a.withLegend &amp;&amp; d.legend_show || (b = c.axis.generateTransitions(a.withTransitionForAxis ? d.transition_duration : 0), c.updateScales(), c.updateSvgSize(), c.transformAll(a.withTransitionForTransform, b)), c.redraw(a, b)
}, i.redrawWithoutRescale = function() {
    this.redraw({
        withY: !1,
        withSubchart: !1,
        withEventRect: !1,
        withTransitionForAxis: !1
    })
}, i.isTimeSeries = function() {
    return &quot;timeseries&quot; === this.config.axis_x_type
}, i.isCategorized = function() {
    return this.config.axis_x_type.indexOf(&quot;categor&quot;) &gt;= 0
}, i.isCustomX = function() {
    var a = this,
    b = a.config;
    return !a.isTimeSeries() &amp;&amp; (b.data_x || v(b.data_xs))
}, i.isTimeSeriesY = function() {
    return &quot;timeseries&quot; === this.config.axis_y_type
}, i.getTranslate = function(a) {
    var b,
    c,
    d = this,
    e = d.config;
    return &quot;main&quot; === a ? (b = s(d.margin.left), c = s(d.margin.top)) : &quot;context&quot; === a ? (b = s(d.margin2.left), c = s(d.margin2.top)) : &quot;legend&quot; === a ? (b = d.margin3.left, c = d.margin3.top) : &quot;x&quot; === a ? (b = 0, c = e.axis_rotated ? 0 : d.height) : &quot;y&quot; === a ? (b = 0, c = e.axis_rotated ? d.height : 0) : &quot;y2&quot; === a ? (b = e.axis_rotated ? 0 : d.width, c = e.axis_rotated ? 1 : 0) : &quot;subx&quot; === a ? (b = 0, c = e.axis_rotated ? 0 : d.height2) : &quot;arc&quot; === a &amp;&amp; (b = d.arcWidth / 2, c = d.arcHeight / 2), &quot;translate(&quot; + b + &quot;,&quot; + c + &quot;)&quot;
}, i.initialOpacity = function(a) {
    return null !== a.value &amp;&amp; this.withoutFadeIn[a.id] ? 1 : 0
}, i.initialOpacityForCircle = function(a) {
    return null !== a.value &amp;&amp; this.withoutFadeIn[a.id] ? this.opacityForCircle(a) : 0
}, i.opacityForCircle = function(a) {
    var b = this.config.point_show ? 1 : 0;
    return m(a.value) ? this.isScatterType(a) ? .5 : b : 0
}, i.opacityForText = function() {
    return this.hasDataLabel() ? 1 : 0
}, i.xx = function(a) {
    return a ? this.x(a.x) : null
}, i.xv = function(a) {
    var b = this,
    c = a.value;
    return b.isTimeSeries() ? c = b.parseDate(a.value) : b.isCategorized() &amp;&amp; &quot;string&quot; == typeof a.value &amp;&amp; (c = b.config.axis_x_categories.indexOf(a.value)), Math.ceil(b.x(c))
}, i.yv = function(a) {
    var b = this,
    c = a.axis &amp;&amp; &quot;y2&quot; === a.axis ? b.y2 : b.y;
    return Math.ceil(c(a.value))
}, i.subxx = function(a) {
    return a ? this.subX(a.x) : null
}, i.transformMain = function(a, b) {
    var c,
    d,
    e,
    f = this;
    b &amp;&amp; b.axisX ? c = b.axisX : (c = f.main.select(&quot;.&quot; + l.axisX), a &amp;&amp; (c = c.transition())), b &amp;&amp; b.axisY ? d = b.axisY : (d = f.main.select(&quot;.&quot; + l.axisY), a &amp;&amp; (d = d.transition())), b &amp;&amp; b.axisY2 ? e = b.axisY2 : (e = f.main.select(&quot;.&quot; + l.axisY2), a &amp;&amp; (e = e.transition())), (a ? f.main.transition() : f.main).attr(&quot;transform&quot;, f.getTranslate(&quot;main&quot;)), c.attr(&quot;transform&quot;, f.getTranslate(&quot;x&quot;)), d.attr(&quot;transform&quot;, f.getTranslate(&quot;y&quot;)), e.attr(&quot;transform&quot;, f.getTranslate(&quot;y2&quot;)), f.main.select(&quot;.&quot; + l.chartArcs).attr(&quot;transform&quot;, f.getTranslate(&quot;arc&quot;))
}, i.transformAll = function(a, b) {
    var c = this;
    c.transformMain(a, b), c.config.subchart_show &amp;&amp; c.transformContext(a, b), c.legend &amp;&amp; c.transformLegend(a)
}, i.updateSvgSize = function() {
    var a = this,
    b = a.svg.select(&quot;.c3-brush .background&quot;);
    a.svg.attr(&quot;width&quot;, a.currentWidth).attr(&quot;height&quot;, a.currentHeight), a.svg.selectAll([&quot;#&quot; + a.clipId, &quot;#&quot; + a.clipIdForGrid]).select(&quot;rect&quot;).attr(&quot;width&quot;, a.width).attr(&quot;height&quot;, a.height), a.svg.select(&quot;#&quot; + a.clipIdForXAxis).select(&quot;rect&quot;).attr(&quot;x&quot;, a.getXAxisClipX.bind(a)).attr(&quot;y&quot;, a.getXAxisClipY.bind(a)).attr(&quot;width&quot;, a.getXAxisClipWidth.bind(a)).attr(&quot;height&quot;, a.getXAxisClipHeight.bind(a)), a.svg.select(&quot;#&quot; + a.clipIdForYAxis).select(&quot;rect&quot;).attr(&quot;x&quot;, a.getYAxisClipX.bind(a)).attr(&quot;y&quot;, a.getYAxisClipY.bind(a)).attr(&quot;width&quot;, a.getYAxisClipWidth.bind(a)).attr(&quot;height&quot;, a.getYAxisClipHeight.bind(a)), a.svg.select(&quot;#&quot; + a.clipIdForSubchart).select(&quot;rect&quot;).attr(&quot;width&quot;, a.width).attr(&quot;height&quot;, b.size() ? b.attr(&quot;height&quot;) : 0), a.svg.select(&quot;.&quot; + l.zoomRect).attr(&quot;width&quot;, a.width).attr(&quot;height&quot;, a.height), a.selectChart.style(&quot;max-height&quot;, a.currentHeight + &quot;px&quot;)
}, i.updateDimension = function(a) {
    var b = this;
    a || (b.config.axis_rotated ? (b.axes.x.call(b.xAxis), b.axes.subx.call(b.subXAxis)) : (b.axes.y.call(b.yAxis), b.axes.y2.call(b.y2Axis))), b.updateSizes(), b.updateScales(), b.updateSvgSize(), b.transformAll(!1)
}, i.observeInserted = function(b) {
    var c,
    d = this;
    return &quot;undefined&quot; == typeof MutationObserver ? void a.console.error(&quot;MutationObserver not defined.&quot;) : (c = new MutationObserver(function(e) {
        e.forEach(function(e) {
            &quot;childList&quot; === e.type &amp;&amp; e.previousSibling &amp;&amp; (c.disconnect(), d.intervalForObserveInserted = a.setInterval(function() {
                b.node().parentNode &amp;&amp; (a.clearInterval(d.intervalForObserveInserted), d.updateDimension(), d.brush &amp;&amp; d.brush.update(), d.config.oninit.call(d), d.redraw({
                    withTransform: !0,
                    withUpdateXDomain: !0,
                    withUpdateOrgXDomain: !0,
                    withTransition: !1,
                    withTransitionForTransform: !1,
                    withLegend: !0
                }), b.transition().style(&quot;opacity&quot;, 1))
            }, 10))
        })
    }), void c.observe(b.node(), {
        attributes: !0,
        childList: !0,
        characterData: !0
    }))
}, i.bindResize = function() {
    var b = this,
    c = b.config;
    if (b.resizeFunction = b.generateResize(), b.resizeFunction.add(function() {
        c.onresize.call(b)
    }), c.resize_auto &amp;&amp; b.resizeFunction.add(function() {
        void 0 !== b.resizeTimeout &amp;&amp; a.clearTimeout(b.resizeTimeout), b.resizeTimeout = a.setTimeout(function() {
            delete b.resizeTimeout, b.api.flush()
        }, 100)
    }), b.resizeFunction.add(function() {
        c.onresized.call(b)
    }), a.attachEvent)
    a.attachEvent(&quot;onresize&quot;, b.resizeFunction);
    else if (a.addEventListener)
    a.addEventListener(&quot;resize&quot;, b.resizeFunction, !1);
    else {
        var d = a.onresize;
        d ? d.add &amp;&amp; d.remove || (d = b.generateResize(), d.add(a.onresize)) : d = b.generateResize(), d.add(b.resizeFunction), a.onresize = d
    }
}, i.generateResize = function() {
    function a() {
        b.forEach(function(a) {
            a()
        })
    }
    var b = [];
    return a.add = function(a) {
        b.push(a)
    }, a.remove = function(a) {
        for (var c = 0; c &lt; b.length; c++)
        if (b[c] === a) {
            b.splice(c, 1);
            break
        }
    }, a
}, i.endall = function(a, b) {
    var c = 0;
    a.each(function() {
        ++c
    }).each(&quot;end&quot;, function() {
        --c || b.apply(this, arguments)
    })
}, i.generateWait = function() {
    var a = [],
    b = function(b, c) {
        var d = setInterval(function() {
            var b = 0;
            a.forEach(function(a) {
                if (a.empty())
                return void (b += 1);
                try {
                    a.transition()
                } catch (c) {
                    b += 1
                }
            }), b === a.length &amp;&amp; (clearInterval(d), c &amp;&amp; c())
        }, 10)
    };
    return b.add = function(b) {
        a.push(b)
    }, b
}, i.parseDate = function(b) {
    var c,
    d = this;
    return b instanceof Date ? c = b : &quot;string&quot; == typeof b ? c = d.dataTimeFormat(d.config.data_xFormat).parse(b) : &quot;number&quot; != typeof b || isNaN(b) || (c = new Date(+b)), c &amp;&amp; !isNaN(+c) || a.console.error(&quot;Failed to parse x &#39;&quot; + b + &quot;&#39; to Date object&quot;), c
}, i.isTabVisible = function() {
    var a;
    return &quot;undefined&quot; != typeof document.hidden ? a = &quot;hidden&quot; : &quot;undefined&quot; != typeof document.mozHidden ? a = &quot;mozHidden&quot; : &quot;undefined&quot; != typeof document.msHidden ? a = &quot;msHidden&quot; : &quot;undefined&quot; != typeof document.webkitHidden &amp;&amp; (a = &quot;webkitHidden&quot;), !document[a]
}, i.getDefaultConfig = function() {
    var a = {
        bindto: &quot;#chart&quot;,
        svg_classname: void 0,
        size_width: void 0,
        size_height: void 0,
        padding_left: void 0,
        padding_right: void 0,
        padding_top: void 0,
        padding_bottom: void 0,
        resize_auto: !0,
        zoom_enabled: !1,
        zoom_extent: void 0,
        zoom_privileged: !1,
        zoom_rescale: !1,
        zoom_onzoom: function() {},
        zoom_onzoomstart: function() {},
        zoom_onzoomend: function() {},
        zoom_x_min: void 0,
        zoom_x_max: void 0,
        interaction_brighten: !0,
        interaction_enabled: !0,
        onmouseover: function() {},
        onmouseout: function() {},
        onresize: function() {},
        onresized: function() {},
        oninit: function() {},
        onrendered: function() {},
        transition_duration: 350,
        data_x: void 0,
        data_xs: {},
        data_xFormat: &quot;%Y-%m-%d&quot;,
        data_xLocaltime: !0,
        data_xSort: !0,
        data_idConverter: function(a) {
            return a
        },
        data_names: {},
        data_classes: {},
        data_groups: [],
        data_axes: {},
        data_type: void 0,
        data_types: {},
        data_labels: {},
        data_order: &quot;desc&quot;,
        data_regions: {},
        data_color: void 0,
        data_colors: {},
        data_hide: !1,
        data_filter: void 0,
        data_selection_enabled: !1,
        data_selection_grouped: !1,
        data_selection_isselectable: function() {
            return !0
        },
        data_selection_multiple: !0,
        data_selection_draggable: !1,
        data_onclick: function() {},
        data_onmouseover: function() {},
        data_onmouseout: function() {},
        data_onselected: function() {},
        data_onunselected: function() {},
        data_url: void 0,
        data_headers: void 0,
        data_json: void 0,
        data_rows: void 0,
        data_columns: void 0,
        data_mimeType: void 0,
        data_keys: void 0,
        data_empty_label_text: &quot;&quot;,
        subchart_show: !1,
        subchart_size_height: 60,
        subchart_axis_x_show: !0,
        subchart_onbrush: function() {},
        color_pattern: [],
        color_threshold: {},
        legend_show: !0,
        legend_hide: !1,
        legend_position: &quot;bottom&quot;,
        legend_inset_anchor: &quot;top-left&quot;,
        legend_inset_x: 10,
        legend_inset_y: 0,
        legend_inset_step: void 0,
        legend_item_onclick: void 0,
        legend_item_onmouseover: void 0,
        legend_item_onmouseout: void 0,
        legend_equally: !1,
        legend_padding: 0,
        legend_item_tile_width: 10,
        legend_item_tile_height: 10,
        axis_rotated: !1,
        axis_x_show: !0,
        axis_x_type: &quot;indexed&quot;,
        axis_x_localtime: !0,
        axis_x_categories: [],
        axis_x_tick_centered: !1,
        axis_x_tick_format: void 0,
        axis_x_tick_culling: {},
        axis_x_tick_culling_max: 10,
        axis_x_tick_count: void 0,
        axis_x_tick_fit: !0,
        axis_x_tick_values: null,
        axis_x_tick_rotate: 0,
        axis_x_tick_outer: !0,
        axis_x_tick_multiline: !0,
        axis_x_tick_width: null,
        axis_x_max: void 0,
        axis_x_min: void 0,
        axis_x_padding: {},
        axis_x_height: void 0,
        axis_x_extent: void 0,
        axis_x_label: {},
        axis_y_show: !0,
        axis_y_type: void 0,
        axis_y_max: void 0,
        axis_y_min: void 0,
        axis_y_inverted: !1,
        axis_y_center: void 0,
        axis_y_inner: void 0,
        axis_y_label: {},
        axis_y_tick_format: void 0,
        axis_y_tick_outer: !0,
        axis_y_tick_values: null,
        axis_y_tick_rotate: 0,
        axis_y_tick_count: void 0,
        axis_y_tick_time_value: void 0,
        axis_y_tick_time_interval: void 0,
        axis_y_padding: {},
        axis_y_default: void 0,
        axis_y2_show: !1,
        axis_y2_max: void 0,
        axis_y2_min: void 0,
        axis_y2_inverted: !1,
        axis_y2_center: void 0,
        axis_y2_inner: void 0,
        axis_y2_label: {},
        axis_y2_tick_format: void 0,
        axis_y2_tick_outer: !0,
        axis_y2_tick_values: null,
        axis_y2_tick_count: void 0,
        axis_y2_padding: {},
        axis_y2_default: void 0,
        grid_x_show: !1,
        grid_x_type: &quot;tick&quot;,
        grid_x_lines: [],
        grid_y_show: !1,
        grid_y_lines: [],
        grid_y_ticks: 10,
        grid_focus_show: !0,
        grid_lines_front: !0,
        point_show: !0,
        point_r: 2.5,
        point_sensitivity: 10,
        point_focus_expand_enabled: !0,
        point_focus_expand_r: void 0,
        point_select_r: void 0,
        line_connectNull: !1,
        line_step_type: &quot;step&quot;,
        bar_width: void 0,
        bar_width_ratio: .6,
        bar_width_max: void 0,
        bar_zerobased: !0,
        area_zerobased: !0,
        area_above: !1,
        pie_label_show: !0,
        pie_label_format: void 0,
        pie_label_threshold: .05,
        pie_label_ratio: void 0,
        pie_expand: {},
        pie_expand_duration: 50,
        gauge_fullCircle: !1,
        gauge_label_show: !0,
        gauge_label_format: void 0,
        gauge_min: 0,
        gauge_max: 100,
        gauge_startingAngle: -1 * Math.PI / 2,
        gauge_units: void 0,
        gauge_width: void 0,
        gauge_expand: {},
        gauge_expand_duration: 50,
        donut_label_show: !0,
        donut_label_format: void 0,
        donut_label_threshold: .05,
        donut_label_ratio: void 0,
        donut_width: void 0,
        donut_title: &quot;&quot;,
        donut_expand: {},
        donut_expand_duration: 50,
        spline_interpolation_type: &quot;cardinal&quot;,
        regions: [],
        tooltip_show: !0,
        tooltip_grouped: !0,
        tooltip_format_title: void 0,
        tooltip_format_name: void 0,
        tooltip_format_value: void 0,
        tooltip_position: void 0,
        tooltip_contents: function(a, b, c, d) {
            return this.getTooltipContent ? this.getTooltipContent(a, b, c, d) : &quot;&quot;
        },
        tooltip_init_show: !1,
        tooltip_init_x: 0,
        tooltip_init_position: {
            top: &quot;0px&quot;,
            left: &quot;50px&quot;
        },
        tooltip_onshow: function() {},
        tooltip_onhide: function() {},
        title_text: void 0,
        title_padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        },
        title_position: &quot;top-center&quot;
    };
    return Object.keys(this.additionalConfig).forEach(function(b) {
        a[b] = this.additionalConfig[b]
    }, this), a
}, i.additionalConfig = {}, i.loadConfig = function(a) {
    function b() {
        var a = d.shift();
        return a &amp;&amp; c &amp;&amp; &quot;object&quot; == typeof c &amp;&amp; a in c ? (c = c[a], b()) : a ? void 0 : c
    }
    var c,
    d,
    e,
    f = this.config;
    Object.keys(f).forEach(function(g) {
        c = a, d = g.split(&quot;_&quot;), e = b(), q(e) &amp;&amp; (f[g] = e)
    })
}, i.getScale = function(a, b, c) {
    return (c ? this.d3.time.scale() : this.d3.scale.linear()).range([a, b])
}, i.getX = function(a, b, c, d) {
    var e,
    f = this,
    g = f.getScale(a, b, f.isTimeSeries()),
    h = c ? g.domain(c) : g;
    f.isCategorized() ? (d = d || function() {
        return 0
    }, g = function(a, b) {
        var c = h(a) + d(a);
        return b ? c : Math.ceil(c)
    }) : g = function(a, b) {
        var c = h(a);
        return b ? c : Math.ceil(c)
    };
    for (e in h)
    g[e] = h[e];
    return g.orgDomain = function() {
        return h.domain()
    }, f.isCategorized() &amp;&amp; (g.domain = function(a) {
        return arguments.length ? (h.domain(a), g) : (a = this.orgDomain(), [a[0], a[1] + 1])
    }), g
}, i.getY = function(a, b, c) {
    var d = this.getScale(a, b, this.isTimeSeriesY());
    return c &amp;&amp; d.domain(c), d
}, i.getYScale = function(a) {
    return &quot;y2&quot; === this.axis.getId(a) ? this.y2 : this.y
}, i.getSubYScale = function(a) {
    return &quot;y2&quot; === this.axis.getId(a) ? this.subY2 : this.subY
}, i.updateScales = function() {
    var a = this,
    b = a.config,
    c = !a.x;
    a.xMin = b.axis_rotated ? 1 : 0, a.xMax = b.axis_rotated ? a.height : a.width, a.yMin = b.axis_rotated ? 0 : a.height, a.yMax = b.axis_rotated ? a.width : 1, a.subXMin = a.xMin, a.subXMax = a.xMax, a.subYMin = b.axis_rotated ? 0 : a.height2, a.subYMax = b.axis_rotated ? a.width2 : 1, a.x = a.getX(a.xMin, a.xMax, c ? void 0 : a.x.orgDomain(), function() {
        return a.xAxis.tickOffset()
    }), a.y = a.getY(a.yMin, a.yMax, c ? b.axis_y_default : a.y.domain()), a.y2 = a.getY(a.yMin, a.yMax, c ? b.axis_y2_default : a.y2.domain()), a.subX = a.getX(a.xMin, a.xMax, a.orgXDomain, function(b) {
        return b % 1 ? 0 : a.subXAxis.tickOffset()
    }), a.subY = a.getY(a.subYMin, a.subYMax, c ? b.axis_y_default : a.subY.domain()), a.subY2 = a.getY(a.subYMin, a.subYMax, c ? b.axis_y2_default : a.subY2.domain()), a.xAxisTickFormat = a.axis.getXAxisTickFormat(), a.xAxisTickValues = a.axis.getXAxisTickValues(), a.yAxisTickValues = a.axis.getYAxisTickValues(), a.y2AxisTickValues = a.axis.getY2AxisTickValues(), a.xAxis = a.axis.getXAxis(a.x, a.xOrient, a.xAxisTickFormat, a.xAxisTickValues, b.axis_x_tick_outer), a.subXAxis = a.axis.getXAxis(a.subX, a.subXOrient, a.xAxisTickFormat, a.xAxisTickValues, b.axis_x_tick_outer), a.yAxis = a.axis.getYAxis(a.y, a.yOrient, b.axis_y_tick_format, a.yAxisTickValues, b.axis_y_tick_outer), a.y2Axis = a.axis.getYAxis(a.y2, a.y2Orient, b.axis_y2_tick_format, a.y2AxisTickValues, b.axis_y2_tick_outer), c || (a.brush &amp;&amp; a.brush.scale(a.subX), b.zoom_enabled &amp;&amp; a.zoom.scale(a.x)), a.updateArc &amp;&amp; a.updateArc()
}, i.getYDomainMin = function(a) {
    var b,
    c,
    d,
    e,
    f,
    g,
    h = this,
    i = h.config,
    j = h.mapToIds(a),
    k = h.getValuesAsIdKeyed(a);
    if (i.data_groups.length &gt; 0)
    for (g = h.hasNegativeValueInTargets(a), b = 0; b &lt; i.data_groups.length; b++)
    if (e = i.data_groups[b].filter(function(a) {
        return j.indexOf(a) &gt;= 0
    }), 0 !== e.length)
    for (d = e[0], g &amp;&amp; k[d] &amp;&amp; k[d].forEach(function(a, b) {
        k[d][b] = 0 &gt; a ? a : 0
    }), c = 1; c &lt; e.length; c++)
    f = e[c], k[f] &amp;&amp; k[f].forEach(function(a, b) {
        h.axis.getId(f) !== h.axis.getId(d) || !k[d] || g &amp;&amp; +a &gt; 0 || (k[d][b] += +a)
    });
    return h.d3.min(Object.keys(k).map(function(a) {
        return h.d3.min(k[a])
    }))
}, i.getYDomainMax = function(a) {
    var b,
    c,
    d,
    e,
    f,
    g,
    h = this,
    i = h.config,
    j = h.mapToIds(a),
    k = h.getValuesAsIdKeyed(a);
    if (i.data_groups.length &gt; 0)
    for (g = h.hasPositiveValueInTargets(a), b = 0; b &lt; i.data_groups.length; b++)
    if (e = i.data_groups[b].filter(function(a) {
        return j.indexOf(a) &gt;= 0
    }), 0 !== e.length)
    for (d = e[0], g &amp;&amp; k[d] &amp;&amp; k[d].forEach(function(a, b) {
        k[d][b] = a &gt; 0 ? a : 0
    }), c = 1; c &lt; e.length; c++)
    f = e[c], k[f] &amp;&amp; k[f].forEach(function(a, b) {
        h.axis.getId(f) !== h.axis.getId(d) || !k[d] || g &amp;&amp; 0 &gt; +a || (k[d][b] += +a)
    });
    return h.d3.max(Object.keys(k).map(function(a) {
        return h.d3.max(k[a])
    }))
}, i.getYDomain = function(a, b, c) {
    var d,
    e,
    f,
    g,
    h,
    i,
    j,
    k,
    l,
    n,
    o,
    p = this,
    q = p.config,
    r = a.filter(function(a) {
        return p.axis.getId(a.id) === b
    }),
    s = c ? p.filterByXDomain(r, c) : r,
    u = &quot;y2&quot; === b ? q.axis_y2_min : q.axis_y_min,
    w = &quot;y2&quot; === b ? q.axis_y2_max : q.axis_y_max,
    x = p.getYDomainMin(s),
    y = p.getYDomainMax(s),
    z = &quot;y2&quot; === b ? q.axis_y2_center : q.axis_y_center,
    A = p.hasType(&quot;bar&quot;, s) &amp;&amp; q.bar_zerobased || p.hasType(&quot;area&quot;, s) &amp;&amp; q.area_zerobased,
    B = &quot;y2&quot; === b ? q.axis_y2_inverted : q.axis_y_inverted,
    C = p.hasDataLabel() &amp;&amp; q.axis_rotated,
    D = p.hasDataLabel() &amp;&amp; !q.axis_rotated;
    return x = m(u) ? u : m(w) ? w &gt; x ? x : w - 10 : x, y = m(w) ? w : m(u) ? y &gt; u ? y : u + 10 : y, 0 === s.length ? &quot;y2&quot; === b ? p.y2.domain() : p.y.domain() : (isNaN(x) &amp;&amp; (x = 0), isNaN(y) &amp;&amp; (y = x), x === y &amp;&amp; (0 &gt; x ? y = 0 : x = 0), n = x &gt;= 0 &amp;&amp; y &gt;= 0, o = 0 &gt;= x &amp;&amp; 0 &gt;= y, (m(u) &amp;&amp; n || m(w) &amp;&amp; o) &amp;&amp; (A = !1), A &amp;&amp; (n &amp;&amp; (x = 0), o &amp;&amp; (y = 0)), e = Math.abs(y - x), f = g = h = .1 * e, &quot;undefined&quot; != typeof z &amp;&amp; (i = Math.max(Math.abs(x), Math.abs(y)), y = z + i, x = z - i), C ? (j = p.getDataLabelLength(x, y, &quot;width&quot;), k = t(p.y.range()), l = [j[0] / k, j[1] / k],
    g += e * (l[1] / (1 - l[0] - l[1])), h += e * (l[0] / (1 - l[0] - l[1]))) : D &amp;&amp; (j = p.getDataLabelLength(x, y, &quot;height&quot;), g += p.axis.convertPixelsToAxisPadding(j[1], e), h += p.axis.convertPixelsToAxisPadding(j[0], e)), &quot;y&quot; === b &amp;&amp; v(q.axis_y_padding) &amp;&amp; (g = p.axis.getPadding(q.axis_y_padding, &quot;top&quot;, g, e), h = p.axis.getPadding(q.axis_y_padding, &quot;bottom&quot;, h, e)), &quot;y2&quot; === b &amp;&amp; v(q.axis_y2_padding) &amp;&amp; (g = p.axis.getPadding(q.axis_y2_padding, &quot;top&quot;, g, e), h = p.axis.getPadding(q.axis_y2_padding, &quot;bottom&quot;, h, e)), A &amp;&amp; (n &amp;&amp; (h = x), o &amp;&amp; (g = -y)), d = [x - h, y + g], B ? d.reverse() : d)
}, i.getXDomainMin = function(a) {
    var b = this,
    c = b.config;
    return q(c.axis_x_min) ? b.isTimeSeries() ? this.parseDate(c.axis_x_min) : c.axis_x_min : b.d3.min(a, function(a) {
        return b.d3.min(a.values, function(a) {
            return a.x
        })
    })
}, i.getXDomainMax = function(a) {
    var b = this,
    c = b.config;
    return q(c.axis_x_max) ? b.isTimeSeries() ? this.parseDate(c.axis_x_max) : c.axis_x_max : b.d3.max(a, function(a) {
        return b.d3.max(a.values, function(a) {
            return a.x
        })
    })
}, i.getXDomainPadding = function(a) {
    var b,
    c,
    d,
    e,
    f = this,
    g = f.config,
    h = a[1] - a[0];
    return f.isCategorized() ? c = 0 : f.hasType(&quot;bar&quot;) ? (b = f.getMaxDataCount(), c = b &gt; 1 ? h / (b - 1) / 2 : .5) : c = .01 * h, &quot;object&quot; == typeof g.axis_x_padding &amp;&amp; v(g.axis_x_padding) ? (d = m(g.axis_x_padding.left) ? g.axis_x_padding.left : c, e = m(g.axis_x_padding.right) ? g.axis_x_padding.right : c) : d = e = &quot;number&quot; == typeof g.axis_x_padding ? g.axis_x_padding : c, {
        left: d,
        right: e
    }
}, i.getXDomain = function(a) {
    var b = this,
    c = [b.getXDomainMin(a), b.getXDomainMax(a)],
    d = c[0],
    e = c[1],
    f = b.getXDomainPadding(c),
    g = 0,
    h = 0;
    return d - e !== 0 || b.isCategorized() || (b.isTimeSeries() ? (d = new Date(.5 * d.getTime()), e = new Date(1.5 * e.getTime())) : (d = 0 === d ? 1 : .5 * d, e = 0 === e ? -1 : 1.5 * e)), (d || 0 === d) &amp;&amp; (g = b.isTimeSeries() ? new Date(d.getTime() - f.left) : d - f.left), (e || 0 === e) &amp;&amp; (h = b.isTimeSeries() ? new Date(e.getTime() + f.right) : e + f.right), [g, h]
}, i.updateXDomain = function(a, b, c, d, e) {
    var f = this,
    g = f.config;
    return c &amp;&amp; (f.x.domain(e ? e : f.d3.extent(f.getXDomain(a))), f.orgXDomain = f.x.domain(), g.zoom_enabled &amp;&amp; f.zoom.scale(f.x).updateScaleExtent(), f.subX.domain(f.x.domain()), f.brush &amp;&amp; f.brush.scale(f.subX)), b &amp;&amp; (f.x.domain(e ? e : !f.brush || f.brush.empty() ? f.orgXDomain : f.brush.extent()), g.zoom_enabled &amp;&amp; f.zoom.scale(f.x).updateScaleExtent()), d &amp;&amp; f.x.domain(f.trimXDomain(f.x.orgDomain())), f.x.domain()
}, i.trimXDomain = function(a) {
    var b = this.getZoomDomain(),
    c = b[0],
    d = b[1];
    return a[0] &lt;= c &amp;&amp; (a[1] = +a[1] + (c - a[0]), a[0] = c), d &lt;= a[1] &amp;&amp; (a[0] = +a[0] - (a[1] - d), a[1] = d), a
}, i.isX = function(a) {
    var b = this,
    c = b.config;
    return c.data_x &amp;&amp; a === c.data_x || v(c.data_xs) &amp;&amp; x(c.data_xs, a)
}, i.isNotX = function(a) {
    return !this.isX(a)
}, i.getXKey = function(a) {
    var b = this,
    c = b.config;
    return c.data_x ? c.data_x : v(c.data_xs) ? c.data_xs[a] : null
}, i.getXValuesOfXKey = function(a, b) {
    var c,
    d = this,
    e = b &amp;&amp; v(b) ? d.mapToIds(b) : [];
    return e.forEach(function(b) {
        d.getXKey(b) === a &amp;&amp; (c = d.data.xs[b])
    }), c
}, i.getIndexByX = function(a) {
    var b = this,
    c = b.filterByX(b.data.targets, a);
    return c.length ? c[0].index : null
}, i.getXValue = function(a, b) {
    var c = this;
    return a in c.data.xs &amp;&amp; c.data.xs[a] &amp;&amp; m(c.data.xs[a][b]) ? c.data.xs[a][b] : b
}, i.getOtherTargetXs = function() {
    var a = this,
    b = Object.keys(a.data.xs);
    return b.length ? a.data.xs[b[0]] : null
}, i.getOtherTargetX = function(a) {
    var b = this.getOtherTargetXs();
    return b &amp;&amp; a &lt; b.length ? b[a] : null
}, i.addXs = function(a) {
    var b = this;
    Object.keys(a).forEach(function(c) {
        b.config.data_xs[c] = a[c]
    })
}, i.hasMultipleX = function(a) {
    return this.d3.set(Object.keys(a).map(function(b) {
        return a[b]
    })).size() &gt; 1
}, i.isMultipleX = function() {
    return v(this.config.data_xs) || !this.config.data_xSort || this.hasType(&quot;scatter&quot;)
}, i.addName = function(a) {
    var b,
    c = this;
    return a &amp;&amp; (b = c.config.data_names[a.id], a.name = void 0 !== b ? b : a.id), a
}, i.getValueOnIndex = function(a, b) {
    var c = a.filter(function(a) {
        return a.index === b
    });
    return c.length ? c[0] : null
}, i.updateTargetX = function(a, b) {
    var c = this;
    a.forEach(function(a) {
        a.values.forEach(function(d, e) {
            d.x = c.generateTargetX(b[e], a.id, e)
        }), c.data.xs[a.id] = b
    })
}, i.updateTargetXs = function(a, b) {
    var c = this;
    a.forEach(function(a) {
        b[a.id] &amp;&amp; c.updateTargetX([a], b[a.id])
    })
}, i.generateTargetX = function(a, b, c) {
    var d,
    e = this;
    return d = e.isTimeSeries() ? a ? e.parseDate(a) : e.parseDate(e.getXValue(b, c)) : e.isCustomX() &amp;&amp; !e.isCategorized() ? m(a) ? +a : e.getXValue(b, c) : c
}, i.cloneTarget = function(a) {
    return {
        id: a.id,
        id_org: a.id_org,
        values: a.values.map(function(a) {
            return {
                x: a.x,
                value: a.value,
                id: a.id
            }
        })
    }
}, i.updateXs = function() {
    var a = this;
    a.data.targets.length &amp;&amp; (a.xs = [], a.data.targets[0].values.forEach(function(b) {
        a.xs[b.index] = b.x
    }))
}, i.getPrevX = function(a) {
    var b = this.xs[a - 1];
    return &quot;undefined&quot; != typeof b ? b : null
}, i.getNextX = function(a) {
    var b = this.xs[a + 1];
    return &quot;undefined&quot; != typeof b ? b : null
}, i.getMaxDataCount = function() {
    var a = this;
    return a.d3.max(a.data.targets, function(a) {
        return a.values.length
    })
}, i.getMaxDataCountTarget = function(a) {
    var b,
    c = a.length,
    d = 0;
    return c &gt; 1 ? a.forEach(function(a) {
        a.values.length &gt; d &amp;&amp; (b = a, d = a.values.length)
    }) : b = c ? a[0] : null, b
}, i.getEdgeX = function(a) {
    var b = this;
    return a.length ? [b.d3.min(a, function(a) {
        return a.values[0].x
    }), b.d3.max(a, function(a) {
        return a.values[a.values.length - 1].x
    })] : [0, 0]
}, i.mapToIds = function(a) {
    return a.map(function(a) {
        return a.id
    })
}, i.mapToTargetIds = function(a) {
    var b = this;
    return a ? [].concat(a) : b.mapToIds(b.data.targets)
}, i.hasTarget = function(a, b) {
    var c,
    d = this.mapToIds(a);
    for (c = 0; c &lt; d.length; c++)
    if (d[c] === b)
    return !0;
    return !1
}, i.isTargetToShow = function(a) {
    return this.hiddenTargetIds.indexOf(a) &lt; 0
}, i.isLegendToShow = function(a) {
    return this.hiddenLegendIds.indexOf(a) &lt; 0
}, i.filterTargetsToShow = function(a) {
    var b = this;
    return a.filter(function(a) {
        return b.isTargetToShow(a.id)
    })
}, i.mapTargetsToUniqueXs = function(a) {
    var b = this,
    c = b.d3.set(b.d3.merge(a.map(function(a) {
        return a.values.map(function(a) {
            return +a.x
        })
    }))).values();
    return c = b.isTimeSeries() ? c.map(function(a) {
        return new Date(+a)
    }) : c.map(function(a) {
        return +a
    }), c.sort(function(a, b) {
        return b &gt; a ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN
    })
}, i.addHiddenTargetIds = function(a) {
    this.hiddenTargetIds = this.hiddenTargetIds.concat(a)
}, i.removeHiddenTargetIds = function(a) {
    this.hiddenTargetIds = this.hiddenTargetIds.filter(function(b) {
        return a.indexOf(b) &lt; 0
    })
}, i.addHiddenLegendIds = function(a) {
    this.hiddenLegendIds = this.hiddenLegendIds.concat(a)
}, i.removeHiddenLegendIds = function(a) {
    this.hiddenLegendIds = this.hiddenLegendIds.filter(function(b) {
        return a.indexOf(b) &lt; 0
    })
}, i.getValuesAsIdKeyed = function(a) {
    var b = {};
    return a.forEach(function(a) {
        b[a.id] = [], a.values.forEach(function(c) {
            b[a.id].push(c.value)
        })
    }), b
}, i.checkValueInTargets = function(a, b) {
    var c,
    d,
    e,
    f = Object.keys(a);
    for (c = 0; c &lt; f.length; c++)
    for (e = a[f[c]].values, d = 0; d &lt; e.length; d++)
    if (b(e[d].value))
    return !0;
    return !1
}, i.hasNegativeValueInTargets = function(a) {
    return this.checkValueInTargets(a, function(a) {
        return 0 &gt; a
    })
}, i.hasPositiveValueInTargets = function(a) {
    return this.checkValueInTargets(a, function(a) {
        return a &gt; 0
    })
}, i.isOrderDesc = function() {
    var a = this.config;
    return &quot;string&quot; == typeof a.data_order &amp;&amp; &quot;desc&quot; === a.data_order.toLowerCase()
}, i.isOrderAsc = function() {
    var a = this.config;
    return &quot;string&quot; == typeof a.data_order &amp;&amp; &quot;asc&quot; === a.data_order.toLowerCase()
}, i.orderTargets = function(a) {
    var b = this,
    c = b.config,
    d = b.isOrderAsc(),
    e = b.isOrderDesc();
    return d || e ? a.sort(function(a, b) {
        var c = function(a, b) {
            return a + Math.abs(b.value)
        },
        e = a.values.reduce(c, 0),
        f = b.values.reduce(c, 0);
        return d ? f - e : e - f
    }) : n(c.data_order) &amp;&amp; a.sort(c.data_order), a
}, i.filterByX = function(a, b) {
    return this.d3.merge(a.map(function(a) {
        return a.values
    })).filter(function(a) {
        return a.x - b === 0
    })
}, i.filterRemoveNull = function(a) {
    return a.filter(function(a) {
        return m(a.value)
    })
}, i.filterByXDomain = function(a, b) {
    return a.map(function(a) {
        return {
            id: a.id,
            id_org: a.id_org,
            values: a.values.filter(function(a) {
                return b[0] &lt;= a.x &amp;&amp; a.x &lt;= b[1]
            })
        }
    })
}, i.hasDataLabel = function() {
    var a = this.config;
    return &quot;boolean&quot; == typeof a.data_labels &amp;&amp; a.data_labels ? !0 : !(&quot;object&quot; != typeof a.data_labels || !v(a.data_labels))
}, i.getDataLabelLength = function(a, b, c) {
    var d = this,
    e = [0, 0],
    f = 1.3;
    return d.selectChart.select(&quot;svg&quot;).selectAll(&quot;.dummy&quot;).data([a, b]).enter().append(&quot;text&quot;).text(function(a) {
        return d.dataLabelFormat(a.id)(a)
    }).each(function(a, b) {
        e[b] = this.getBoundingClientRect()[c] * f
    }).remove(), e
}, i.isNoneArc = function(a) {
    return this.hasTarget(this.data.targets, a.id)
}, i.isArc = function(a) {
    return &quot;data&quot; in a &amp;&amp; this.hasTarget(this.data.targets, a.data.id)
}, i.findSameXOfValues = function(a, b) {
    var c,
    d = a[b].x,
    e = [];
    for (c = b - 1; c &gt;= 0 &amp;&amp; d === a[c].x; c--)
    e.push(a[c]);
    for (c = b; c &lt; a.length &amp;&amp; d === a[c].x; c++)
    e.push(a[c]);
    return e
}, i.findClosestFromTargets = function(a, b) {
    var c,
    d = this;
    return c = a.map(function(a) {
        return d.findClosest(a.values, b)
    }), d.findClosest(c, b)
}, i.findClosest = function(a, b) {
    var c,
    d = this,
    e = d.config.point_sensitivity;
    return a.filter(function(a) {
        return a &amp;&amp; d.isBarType(a.id)
    }).forEach(function(a) {
        var b = d.main.select(&quot;.&quot; + l.bars + d.getTargetSelectorSuffix(a.id) + &quot; .&quot; + l.bar + &quot;-&quot; + a.index).node();
        !c &amp;&amp; d.isWithinBar(b) &amp;&amp; (c = a)
    }), a.filter(function(a) {
        return a &amp;&amp; !d.isBarType(a.id)
    }).forEach(function(a) {
        var f = d.dist(a, b);
        e &gt; f &amp;&amp; (e = f, c = a)
    }), c
}, i.dist = function(a, b) {
    var c = this,
    d = c.config,
    e = d.axis_rotated ? 1 : 0,
    f = d.axis_rotated ? 0 : 1,
    g = c.circleY(a, a.index),
    h = c.x(a.x);
    return Math.sqrt(Math.pow(h - b[e], 2) + Math.pow(g - b[f], 2))
}, i.convertValuesToStep = function(a) {
    var b,
    c = [].concat(a);
    if (!this.isCategorized())
    return a;
    for (b = a.length + 1; b &gt; 0; b--)
    c[b] = c[b - 1];
    return c[0] = {
        x: c[0].x - 1,
        value: c[0].value,
        id: c[0].id
    }, c[a.length + 1] = {
        x: c[a.length].x + 1,
        value: c[a.length].value,
        id: c[a.length].id
    }, c
}, i.updateDataAttributes = function(a, b) {
    var c = this,
    d = c.config,
    e = d[&quot;data_&quot; + a];
    return &quot;undefined&quot; == typeof b ? e : (Object.keys(b).forEach(function(a) {
        e[a] = b[a]
    }), c.redraw({
        withLegend: !0
    }), e)
}, i.convertUrlToData = function(a, b, c, d, e) {
    var f = this,
    g = b ? b : &quot;csv&quot;,
    h = f.d3.xhr(a);
    c &amp;&amp; Object.keys(c).forEach(function(a) {
        h.header(a, c[a])
    }), h.get(function(a, b) {
        var c;
        if (!b)
        throw new Error(a.responseURL + &quot; &quot; + a.status + &quot; (&quot; + a.statusText + &quot;)&quot;);
        c = &quot;json&quot; === g ? f.convertJsonToData(JSON.parse(b.response), d) : &quot;tsv&quot; === g ? f.convertTsvToData(b.response) : f.convertCsvToData(b.response), e.call(f, c)
    })
}, i.convertXsvToData = function(a, b) {
    var c,
    d = b.parseRows(a);
    return 1 === d.length ? (c = [{}], d[0].forEach(function(a) {
        c[0][a] = null
    })) : c = b.parse(a), c
}, i.convertCsvToData = function(a) {
    return this.convertXsvToData(a, this.d3.csv)
}, i.convertTsvToData = function(a) {
    return this.convertXsvToData(a, this.d3.tsv)
}, i.convertJsonToData = function(a, b) {
    var c,
    d,
    e = this,
    f = [];
    return b ? (b.x ? (c = b.value.concat(b.x), e.config.data_x = b.x) : c = b.value, f.push(c), a.forEach(function(a) {
        var b = [];
        c.forEach(function(c) {
            var d = e.findValueInJson(a, c);
            p(d) &amp;&amp; (d = null), b.push(d)
        }), f.push(b)
    }), d = e.convertRowsToData(f)) : (Object.keys(a).forEach(function(b) {
        f.push([b].concat(a[b]))
    }), d = e.convertColumnsToData(f)), d
}, i.findValueInJson = function(a, b) {
    b = b.replace(/\[(\w+)\]/g, &quot;.$1&quot;), b = b.replace(/^\./, &quot;&quot;);
    for (var c = b.split(&quot;.&quot;), d = 0; d &lt; c.length; ++d) {
        var e = c[d];
        if (!(e in a))
        return;
        a = a[e]
    }
    return a
}, i.convertRowsToData = function(a) {
    var b,
    c,
    d = a[0],
    e = {},
    f = [];
    for (b = 1; b &lt; a.length; b++) {
        for (e = {}, c = 0; c &lt; a[b].length; c++) {
            if (p(a[b][c]))
            throw new Error(&quot;Source data is missing a component at (&quot; + b + &quot;,&quot; + c + &quot;)!&quot;);
            e[d[c]] = a[b][c]
        }
        f.push(e)
    }
    return f
}, i.convertColumnsToData = function(a) {
    var b,
    c,
    d,
    e = [];
    for (b = 0; b &lt; a.length; b++)
    for (d = a[b][0], c = 1; c &lt; a[b].length; c++) {
        if (p(e[c - 1]) &amp;&amp; (e[c - 1] = {}), p(a[b][c]))
        throw new Error(&quot;Source data is missing a component at (&quot; + b + &quot;,&quot; + c + &quot;)!&quot;);
        e[c - 1][d] = a[b][c]
    }
    return e
}, i.convertDataToTargets = function(a, b) {
    var c,
    d = this,
    e = d.config,
    f = d.d3.keys(a[0]).filter(d.isNotX, d),
    g = d.d3.keys(a[0]).filter(d.isX, d);
    return f.forEach(function(c) {
        var f = d.getXKey(c);
        d.isCustomX() || d.isTimeSeries() ? g.indexOf(f) &gt;= 0 ? d.data.xs[c] = (b &amp;&amp; d.data.xs[c] ? d.data.xs[c] : []).concat(a.map(function(a) {
            return a[f]
        }).filter(m).map(function(a, b) {
            return d.generateTargetX(a, c, b)
        })) : e.data_x ? d.data.xs[c] = d.getOtherTargetXs() : v(e.data_xs) &amp;&amp; (d.data.xs[c] = d.getXValuesOfXKey(f, d.data.targets)) : d.data.xs[c] = a.map(function(a, b) {
            return b
        })
    }), f.forEach(function(a) {
        if (!d.data.xs[a])
        throw new Error(&#39;x is not defined for id = &quot;&#39; + a + &#39;&quot;.&#39;)
    }), c = f.map(function(b, c) {
        var f = e.data_idConverter(b);
        return {
            id: f,
            id_org: b,
            values: a.map(function(a, g) {
                var h,
                i = d.getXKey(b),
                j = a[i],
                k = null === a[b] || isNaN(a[b]) ? null : +a[b];
                return d.isCustomX() &amp;&amp; d.isCategorized() &amp;&amp; 0 === c &amp;&amp; !p(j) ? (0 === c &amp;&amp; 0 === g &amp;&amp; (e.axis_x_categories = []), h = e.axis_x_categories.indexOf(j), -1 === h &amp;&amp; (h = e.axis_x_categories.length, e.axis_x_categories.push(j))) : h = d.generateTargetX(j, b, g), (p(a[b]) || d.data.xs[b].length &lt;= g) &amp;&amp; (h = void 0), {
                    x: h,
                    value: k,
                    id: f
                }
            }).filter(function(a) {
                return q(a.x)
            })
        }
    }), c.forEach(function(a) {
        var b;
        e.data_xSort &amp;&amp; (a.values = a.values.sort(function(a, b) {
            var c = a.x || 0 === a.x ? a.x : 1 / 0,
            d = b.x || 0 === b.x ? b.x : 1 / 0;
            return c - d
        })), b = 0, a.values.forEach(function(a) {
            a.index = b++
        }), d.data.xs[a.id].sort(function(a, b) {
            return a - b
        })
    }), d.hasNegativeValue = d.hasNegativeValueInTargets(c), d.hasPositiveValue = d.hasPositiveValueInTargets(c), e.data_type &amp;&amp; d.setTargetType(d.mapToIds(c).filter(function(a) {
        return !(a in e.data_types)
    }), e.data_type), c.forEach(function(a) {
        d.addCache(a.id_org, a)
    }), c
}, i.load = function(a, b) {
    var c = this;
    a &amp;&amp; (b.filter &amp;&amp; (a = a.filter(b.filter)), (b.type || b.types) &amp;&amp; a.forEach(function(a) {
        var d = b.types &amp;&amp; b.types[a.id] ? b.types[a.id] : b.type;
        c.setTargetType(a.id, d)
    }), c.data.targets.forEach(function(b) {
        for (var c = 0; c &lt; a.length; c++)
        if (b.id === a[c].id) {
            b.values = a[c].values, a.splice(c, 1);
            break
        }
    }), c.data.targets = c.data.targets.concat(a)), c.updateTargets(c.data.targets), c.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
    }), b.done &amp;&amp; b.done()
}, i.loadFromArgs = function(a) {
    var b = this;
    a.data ? b.load(b.convertDataToTargets(a.data), a) : a.url ? b.convertUrlToData(a.url, a.mimeType, a.headers, a.keys, function(c) {
        b.load(b.convertDataToTargets(c), a)
    }) : a.json ? b.load(b.convertDataToTargets(b.convertJsonToData(a.json, a.keys)), a) : a.rows ? b.load(b.convertDataToTargets(b.convertRowsToData(a.rows)), a) : a.columns ? b.load(b.convertDataToTargets(b.convertColumnsToData(a.columns)), a) : b.load(null, a)
}, i.unload = function(a, b) {
    var c = this;
    return b || (b = function() {}), a = a.filter(function(a) {
        return c.hasTarget(c.data.targets, a)
    }), a &amp;&amp; 0 !== a.length ? (c.svg.selectAll(a.map(function(a) {
        return c.selectorTarget(a)
    })).transition().style(&quot;opacity&quot;, 0).remove().call(c.endall, b), void a.forEach(function(a) {
        c.withoutFadeIn[a] = !1, c.legend &amp;&amp; c.legend.selectAll(&quot;.&quot; + l.legendItem + c.getTargetSelectorSuffix(a)).remove(), c.data.targets = c.data.targets.filter(function(b) {
            return b.id !== a
        })
    })) : void b()
}, i.categoryName = function(a) {
    var b = this.config;
    return a &lt; b.axis_x_categories.length ? b.axis_x_categories[a] : a
}, i.initEventRect = function() {
    var a = this;
    a.main.select(&quot;.&quot; + l.chart).append(&quot;g&quot;).attr(&quot;class&quot;, l.eventRects).style(&quot;fill-opacity&quot;, 0)
}, i.redrawEventRect = function() {
    var a,
    b,
    c = this,
    d = c.config,
    e = c.isMultipleX(),
    f = c.main.select(&quot;.&quot; + l.eventRects).style(&quot;cursor&quot;, d.zoom_enabled ? d.axis_rotated ? &quot;ns-resize&quot; : &quot;ew-resize&quot; : null).classed(l.eventRectsMultiple, e).classed(l.eventRectsSingle, !e);
    f.selectAll(&quot;.&quot; + l.eventRect).remove(), c.eventRect = f.selectAll(&quot;.&quot; + l.eventRect), e ? (a = c.eventRect.data([0]), c.generateEventRectsForMultipleXs(a.enter()), c.updateEventRect(a)) : (b = c.getMaxDataCountTarget(c.data.targets), f.datum(b ? b.values : []), c.eventRect = f.selectAll(&quot;.&quot; + l.eventRect), a = c.eventRect.data(function(a) {
        return a
    }), c.generateEventRectsForSingleX(a.enter()), c.updateEventRect(a), a.exit().remove())
}, i.updateEventRect = function(a) {
    var b,
    c,
    d,
    e,
    f,
    g,
    h = this,
    i = h.config;
    a = a || h.eventRect.data(function(a) {
        return a
    }), h.isMultipleX() ? (b = 0, c = 0, d = h.width, e = h.height) : (!h.isCustomX() &amp;&amp; !h.isTimeSeries() || h.isCategorized() ? (f = h.getEventRectWidth(), g = function(a) {
        return h.x(a.x) - f / 2
    }) : (h.updateXs(), f = function(a) {
        var b = h.getPrevX(a.index),
        c = h.getNextX(a.index);
        return null === b &amp;&amp; null === c ? i.axis_rotated ? h.height : h.width : (null === b &amp;&amp; (b = h.x.domain()[0]), null === c &amp;&amp; (c = h.x.domain()[1]), Math.max(0, (h.x(c) - h.x(b)) / 2))
    }, g = function(a) {
        var b = h.getPrevX(a.index),
        c = h.getNextX(a.index),
        d = h.data.xs[a.id][a.index];
        return null === b &amp;&amp; null === c ? 0 : (null === b &amp;&amp; (b = h.x.domain()[0]), (h.x(d) + h.x(b)) / 2)
    }), b = i.axis_rotated ? 0 : g, c = i.axis_rotated ? g : 0, d = i.axis_rotated ? h.width : f, e = i.axis_rotated ? f : h.height), a.attr(&quot;class&quot;, h.classEvent.bind(h)).attr(&quot;x&quot;, b).attr(&quot;y&quot;, c).attr(&quot;width&quot;, d).attr(&quot;height&quot;, e)
}, i.generateEventRectsForSingleX = function(a) {
    var b = this,
    c = b.d3,
    d = b.config;
    a.append(&quot;rect&quot;).attr(&quot;class&quot;, b.classEvent.bind(b)).style(&quot;cursor&quot;, d.data_selection_enabled &amp;&amp; d.data_selection_grouped ? &quot;pointer&quot; : null).on(&quot;mouseover&quot;, function(a) {
        var c = a.index;
        b.dragging || b.flowing || b.hasArcType() || (d.point_focus_expand_enabled &amp;&amp; b.expandCircles(c, null, !0), b.expandBars(c, null, !0), b.main.selectAll(&quot;.&quot; + l.shape + &quot;-&quot; + c).each(function(a) {
            d.data_onmouseover.call(b.api, a)
        }))
    }).on(&quot;mouseout&quot;, function(a) {
        var c = a.index;
        b.config &amp;&amp; (b.hasArcType() || (b.hideXGridFocus(), b.hideTooltip(), b.unexpandCircles(), b.unexpandBars(), b.main.selectAll(&quot;.&quot; + l.shape + &quot;-&quot; + c).each(function(a) {
            d.data_onmouseout.call(b.api, a)
        })))
    }).on(&quot;mousemove&quot;, function(a) {
        var e,
        f = a.index,
        g = b.svg.select(&quot;.&quot; + l.eventRect + &quot;-&quot; + f);
        b.dragging || b.flowing || b.hasArcType() || (b.isStepType(a) &amp;&amp; &quot;step-after&quot; === b.config.line_step_type &amp;&amp; c.mouse(this)[0] &lt; b.x(b.getXValue(a.id, f)) &amp;&amp; (f -= 1), e = b.filterTargetsToShow(b.data.targets).map(function(a) {
            return b.addName(b.getValueOnIndex(a.values, f))
        }), d.tooltip_grouped &amp;&amp; (b.showTooltip(e, this), b.showXGridFocus(e)), (!d.tooltip_grouped || d.data_selection_enabled &amp;&amp; !d.data_selection_grouped) &amp;&amp; b.main.selectAll(&quot;.&quot; + l.shape + &quot;-&quot; + f).each(function() {
            c.select(this).classed(l.EXPANDED, !0), d.data_selection_enabled &amp;&amp; g.style(&quot;cursor&quot;, d.data_selection_grouped ? &quot;pointer&quot; : null), d.tooltip_grouped || (b.hideXGridFocus(), b.hideTooltip(), d.data_selection_grouped || (b.unexpandCircles(f), b.unexpandBars(f)))
        }).filter(function(a) {
            return b.isWithinShape(this, a)
        }).each(function(a) {
            d.data_selection_enabled &amp;&amp; (d.data_selection_grouped || d.data_selection_isselectable(a)) &amp;&amp; g.style(&quot;cursor&quot;, &quot;pointer&quot;), d.tooltip_grouped || (b.showTooltip([a], this), b.showXGridFocus([a]), d.point_focus_expand_enabled &amp;&amp; b.expandCircles(f, a.id, !0), b.expandBars(f, a.id, !0))
        }))
    }).on(&quot;click&quot;, function(a) {
        var e = a.index;
        if (!b.hasArcType() &amp;&amp; b.toggleShape) {
            if (b.cancelClick)
            return void (b.cancelClick = !1);
            b.isStepType(a) &amp;&amp; &quot;step-after&quot; === d.line_step_type &amp;&amp; c.mouse(this)[0] &lt; b.x(b.getXValue(a.id, e)) &amp;&amp; (e -= 1), b.main.selectAll(&quot;.&quot; + l.shape + &quot;-&quot; + e).each(function(a) {
                (d.data_selection_grouped || b.isWithinShape(this, a)) &amp;&amp; (b.toggleShape(this, a, e), b.config.data_onclick.call(b.api, a, this))
            })
        }
    }).call(d.data_selection_draggable &amp;&amp; b.drag ? c.behavior.drag().origin(Object).on(&quot;drag&quot;, function() {
        b.drag(c.mouse(this))
    }).on(&quot;dragstart&quot;, function() {
        b.dragstart(c.mouse(this))
    }).on(&quot;dragend&quot;, function() {
        b.dragend()
    }) : function() {})
}, i.generateEventRectsForMultipleXs = function(a) {
    function b() {
        c.svg.select(&quot;.&quot; + l.eventRect).style(&quot;cursor&quot;, null), c.hideXGridFocus(), c.hideTooltip(), c.unexpandCircles(), c.unexpandBars()
    }
    var c = this,
    d = c.d3,
    e = c.config;
    a.append(&quot;rect&quot;).attr(&quot;x&quot;, 0).attr(&quot;y&quot;, 0).attr(&quot;width&quot;, c.width).attr(&quot;height&quot;, c.height).attr(&quot;class&quot;, l.eventRect).on(&quot;mouseout&quot;, function() {
        c.config &amp;&amp; (c.hasArcType() || b())
    }).on(&quot;mousemove&quot;, function() {
        var a,
        f,
        g,
        h,
        i = c.filterTargetsToShow(c.data.targets);
        if (!c.dragging &amp;&amp; !c.hasArcType(i)) {
            if (a = d.mouse(this), f = c.findClosestFromTargets(i, a), !c.mouseover || f &amp;&amp; f.id === c.mouseover.id || (e.data_onmouseout.call(c.api, c.mouseover), c.mouseover = void 0), !f)
            return void b();
            g = c.isScatterType(f) || !e.tooltip_grouped ? [f] : c.filterByX(i, f.x), h = g.map(function(a) {
                return c.addName(a)
            }), c.showTooltip(h, this), e.point_focus_expand_enabled &amp;&amp; c.expandCircles(f.index, f.id, !0), c.expandBars(f.index, f.id, !0), c.showXGridFocus(h), (c.isBarType(f.id) || c.dist(f, a) &lt; e.point_sensitivity) &amp;&amp; (c.svg.select(&quot;.&quot; + l.eventRect).style(&quot;cursor&quot;, &quot;pointer&quot;), c.mouseover || (e.data_onmouseover.call(c.api, f), c.mouseover = f))
        }
    }).on(&quot;click&quot;, function() {
        var a,
        b,
        f = c.filterTargetsToShow(c.data.targets);
        c.hasArcType(f) || (a = d.mouse(this), b = c.findClosestFromTargets(f, a), b &amp;&amp; (c.isBarType(b.id) || c.dist(b, a) &lt; e.point_sensitivity) &amp;&amp; c.main.selectAll(&quot;.&quot; + l.shapes + c.getTargetSelectorSuffix(b.id)).selectAll(&quot;.&quot; + l.shape + &quot;-&quot; + b.index).each(function() {
            (e.data_selection_grouped || c.isWithinShape(this, b)) &amp;&amp; (c.toggleShape(this, b, b.index), c.config.data_onclick.call(c.api, b, this))
        }))
    }).call(e.data_selection_draggable &amp;&amp; c.drag ? d.behavior.drag().origin(Object).on(&quot;drag&quot;, function() {
        c.drag(d.mouse(this))
    }).on(&quot;dragstart&quot;, function() {
        c.dragstart(d.mouse(this))
    }).on(&quot;dragend&quot;, function() {
        c.dragend()
    }) : function() {})
}, i.dispatchEvent = function(b, c, d) {
    var e = this,
    f = &quot;.&quot; + l.eventRect + (e.isMultipleX() ? &quot;&quot; : &quot;-&quot; + c),
    g = e.main.select(f).node(),
    h = g.getBoundingClientRect(),
    i = h.left + (d ? d[0] : 0),
    j = h.top + (d ? d[1] : 0),
    k = document.createEvent(&quot;MouseEvents&quot;);
    k.initMouseEvent(b, !0, !0, a, 0, i, j, i, j, !1, !1, !1, !1, 0, null), g.dispatchEvent(k)
}, i.getCurrentWidth = function() {
    var a = this,
    b = a.config;
    return b.size_width ? b.size_width : a.getParentWidth()
}, i.getCurrentHeight = function() {
    var a = this,
    b = a.config,
    c = b.size_height ? b.size_height : a.getParentHeight();
    return c &gt; 0 ? c : 320 / (a.hasType(&quot;gauge&quot;) &amp;&amp; !b.gauge_fullCircle ? 2 : 1)
}, i.getCurrentPaddingTop = function() {
    var a = this,
    b = a.config,
    c = m(b.padding_top) ? b.padding_top : 0;
    return a.title &amp;&amp; a.title.node() &amp;&amp; (c += a.getTitlePadding()), c
}, i.getCurrentPaddingBottom = function() {
    var a = this.config;
    return m(a.padding_bottom) ? a.padding_bottom : 0
}, i.getCurrentPaddingLeft = function(a) {
    var b = this,
    c = b.config;
    return m(c.padding_left) ? c.padding_left : c.axis_rotated ? c.axis_x_show ? Math.max(r(b.getAxisWidthByAxisId(&quot;x&quot;, a)), 40) : 1 : !c.axis_y_show || c.axis_y_inner ? b.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : r(b.getAxisWidthByAxisId(&quot;y&quot;, a))
}, i.getCurrentPaddingRight = function() {
    var a = this,
    b = a.config,
    c = 10,
    d = a.isLegendRight ? a.getLegendWidth() + 20 : 0;
    return m(b.padding_right) ? b.padding_right + 1 : b.axis_rotated ? c + d : !b.axis_y2_show || b.axis_y2_inner ? 2 + d + (a.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : r(a.getAxisWidthByAxisId(&quot;y2&quot;)) + d
}, i.getParentRectValue = function(a) {
    for (var b, c = this.selectChart.node(); c &amp;&amp; &quot;BODY&quot; !== c.tagName;) {
        try {
            b = c.getBoundingClientRect()[a]
        } catch (d) {
            &quot;width&quot; === a &amp;&amp; (b = c.offsetWidth)
        }
        if (b)
        break;
        c = c.parentNode
    }
    return b
}, i.getParentWidth = function() {
    return this.getParentRectValue(&quot;width&quot;)
}, i.getParentHeight = function() {
    var a = this.selectChart.style(&quot;height&quot;);
    return a.indexOf(&quot;px&quot;) &gt; 0 ? +a.replace(&quot;px&quot;, &quot;&quot;) : 0
}, i.getSvgLeft = function(a) {
    var b = this,
    c = b.config,
    d = c.axis_rotated || !c.axis_rotated &amp;&amp; !c.axis_y_inner,
    e = c.axis_rotated ? l.axisX : l.axisY,
    f = b.main.select(&quot;.&quot; + e).node(),
    g = f &amp;&amp; d ? f.getBoundingClientRect() : {
        right: 0
    },
    h = b.selectChart.node().getBoundingClientRect(),
    i = b.hasArcType(),
    j = g.right - h.left - (i ? 0 : b.getCurrentPaddingLeft(a));
    return j &gt; 0 ? j : 0
}, i.getAxisWidthByAxisId = function(a, b) {
    var c = this,
    d = c.axis.getLabelPositionById(a);
    return c.axis.getMaxTickWidth(a, b) + (d.isInner ? 20 : 40)
}, i.getHorizontalAxisHeight = function(a) {
    var b = this,
    c = b.config,
    d = 30;
    return &quot;x&quot; !== a || c.axis_x_show ? &quot;x&quot; === a &amp;&amp; c.axis_x_height ? c.axis_x_height : &quot;y&quot; !== a || c.axis_y_show ? &quot;y2&quot; !== a || c.axis_y2_show ? (&quot;x&quot; === a &amp;&amp; !c.axis_rotated &amp;&amp; c.axis_x_tick_rotate &amp;&amp; (d = 30 + b.axis.getMaxTickWidth(a) * Math.cos(Math.PI * (90 - c.axis_x_tick_rotate) / 180)), &quot;y&quot; === a &amp;&amp; c.axis_rotated &amp;&amp; c.axis_y_tick_rotate &amp;&amp; (d = 30 + b.axis.getMaxTickWidth(a) * Math.cos(Math.PI * (90 - c.axis_y_tick_rotate) / 180)), d + (b.axis.getLabelPositionById(a).isInner ? 0 : 10) + (&quot;y2&quot; === a ? -10 : 0)) : b.rotated_padding_top : !c.legend_show || b.isLegendRight || b.isLegendInset ? 1 : 10 : 8
}, i.getEventRectWidth = function() {
    return Math.max(0, this.xAxis.tickInterval())
}, i.getShapeIndices = function(a) {
    var b,
    c,
    d = this,
    e = d.config,
    f = {},
    g = 0;
    return d.filterTargetsToShow(d.data.targets.filter(a, d)).forEach(function(a) {
        for (b = 0; b &lt; e.data_groups.length; b++)
        if (!(e.data_groups[b].indexOf(a.id) &lt; 0))
        for (c = 0; c &lt; e.data_groups[b].length; c++)
        if (e.data_groups[b][c] in f) {
            f[a.id] = f[e.data_groups[b][c]];
            break
        }
        p(f[a.id]) &amp;&amp; (f[a.id] = g++)
    }), f.__max__ = g - 1, f
}, i.getShapeX = function(a, b, c, d) {
    var e = this,
    f = d ? e.subX : e.x;
    return function(d) {
        var e = d.id in c ? c[d.id] : 0;
        return d.x || 0 === d.x ? f(d.x) - a * (b / 2 - e) : 0
    }
}, i.getShapeY = function(a) {
    var b = this;
    return function(c) {
        var d = a ? b.getSubYScale(c.id) : b.getYScale(c.id);
        return d(c.value)
    }
}, i.getShapeOffset = function(a, b, c) {
    var d = this,
    e = d.orderTargets(d.filterTargetsToShow(d.data.targets.filter(a, d))),
    f = e.map(function(a) {
        return a.id
    });
    return function(a, g) {
        var h = c ? d.getSubYScale(a.id) : d.getYScale(a.id),
        i = h(0),
        j = i;
        return e.forEach(function(c) {
            var e = d.isStepType(a) ? d.convertValuesToStep(c.values) : c.values;
            c.id !== a.id &amp;&amp; b[c.id] === b[a.id] &amp;&amp; f.indexOf(c.id) &lt; f.indexOf(a.id) &amp;&amp; (&quot;undefined&quot; != typeof e[g] &amp;&amp; +e[g].x === +a.x || (g = -1, e.forEach(function(b, c) {
                b.x === a.x &amp;&amp; (g = c)
            })), g in e &amp;&amp; e[g].value * a.value &gt;= 0 &amp;&amp; (j += h(e[g].value) - i))
        }), j
    }
}, i.isWithinShape = function(a, b) {
    var c,
    d = this,
    e = d.d3.select(a);
    return d.isTargetToShow(b.id) ? &quot;circle&quot; === a.nodeName ? c = d.isStepType(b) ? d.isWithinStep(a, d.getYScale(b.id)(b.value)) : d.isWithinCircle(a, 1.5 * d.pointSelectR(b)) : &quot;path&quot; === a.nodeName &amp;&amp; (c = e.classed(l.bar) ? d.isWithinBar(a) : !0) : c = !1, c
}, i.getInterpolate = function(a) {
    var b = this,
    c = b.isInterpolationType(b.config.spline_interpolation_type) ? b.config.spline_interpolation_type : &quot;cardinal&quot;;
    return b.isSplineType(a) ? c : b.isStepType(a) ? b.config.line_step_type : &quot;linear&quot;
}, i.initLine = function() {
    var a = this;
    a.main.select(&quot;.&quot; + l.chart).append(&quot;g&quot;).attr(&quot;class&quot;, l.chartLines)
}, i.updateTargetsForLine = function(a) {
    var b,
    c,
    d = this,
    e = d.config,
    f = d.classChartLine.bind(d),
    g = d.classLines.bind(d),
    h = d.classAreas.bind(d),
    i = d.classCircles.bind(d),
    j = d.classFocus.bind(d);
    b = d.main.select(&quot;.&quot; + l.chartLines).selectAll(&quot;.&quot; + l.chartLine).data(a).attr(&quot;class&quot;, function(a) {
        return f(a) + j(a)
    }), c = b.enter().append(&quot;g&quot;).attr(&quot;class&quot;, f).style(&quot;opacity&quot;, 0).style(&quot;pointer-events&quot;, &quot;none&quot;), c.append(&quot;g&quot;).attr(&quot;class&quot;, g), c.append(&quot;g&quot;).attr(&quot;class&quot;, h), c.append(&quot;g&quot;).attr(&quot;class&quot;, function(a) {
        return d.generateClass(l.selectedCircles, a.id)
    }), c.append(&quot;g&quot;).attr(&quot;class&quot;, i).style(&quot;cursor&quot;, function(a) {
        return e.data_selection_isselectable(a) ? &quot;pointer&quot; : null
    }), a.forEach(function(a) {
        d.main.selectAll(&quot;.&quot; + l.selectedCircles + d.getTargetSelectorSuffix(a.id)).selectAll(&quot;.&quot; + l.selectedCircle).each(function(b) {
            b.value = a.values[b.index].value
        })
    })
}, i.updateLine = function(a) {
    var b = this;
    b.mainLine = b.main.selectAll(&quot;.&quot; + l.lines).selectAll(&quot;.&quot; + l.line).data(b.lineData.bind(b)), b.mainLine.enter().append(&quot;path&quot;).attr(&quot;class&quot;, b.classLine.bind(b)).style(&quot;stroke&quot;, b.color), b.mainLine.style(&quot;opacity&quot;, b.initialOpacity.bind(b)).style(&quot;shape-rendering&quot;, function(a) {
        return b.isStepType(a) ? &quot;crispEdges&quot; : &quot;&quot;
    }).attr(&quot;transform&quot;, null), b.mainLine.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove()
}, i.redrawLine = function(a, b) {
    return [(b ? this.mainLine.transition(Math.random().toString()) : this.mainLine).attr(&quot;d&quot;, a).style(&quot;stroke&quot;, this.color).style(&quot;opacity&quot;, 1)]
}, i.generateDrawLine = function(a, b) {
    var c = this,
    d = c.config,
    e = c.d3.svg.line(),
    f = c.generateGetLinePoints(a, b),
    g = b ? c.getSubYScale : c.getYScale,
    h = function(a) {
        return (b ? c.subxx : c.xx).call(c, a)
    },
    i = function(a, b) {
        return d.data_groups.length &gt; 0 ? f(a, b)[0][1] : g.call(c, a.id)(a.value)
    };
    return e = d.axis_rotated ? e.x(i).y(h) : e.x(h).y(i), d.line_connectNull || (e = e.defined(function(a) {
        return null != a.value
    })), function(a) {
        var f,
        h = d.line_connectNull ? c.filterRemoveNull(a.values) : a.values,
        i = b ? c.x : c.subX,
        j = g.call(c, a.id),
        k = 0,
        l = 0;
        return c.isLineType(a) ? d.data_regions[a.id] ? f = c.lineWithRegions(h, i, j, d.data_regions[a.id]) : (c.isStepType(a) &amp;&amp; (h = c.convertValuesToStep(h)), f = e.interpolate(c.getInterpolate(a))(h)) : (h[0] &amp;&amp; (k = i(h[0].x), l = j(h[0].value)), f = d.axis_rotated ? &quot;M &quot; + l + &quot; &quot; + k : &quot;M &quot; + k + &quot; &quot; + l), f ? f : &quot;M 0 0&quot;
    }
}, i.generateGetLinePoints = function(a, b) {
    var c = this,
    d = c.config,
    e = a.__max__ + 1,
    f = c.getShapeX(0, e, a, !!b),
    g = c.getShapeY(!!b),
    h = c.getShapeOffset(c.isLineType, a, !!b),
    i = b ? c.getSubYScale : c.getYScale;
    return function(a, b) {
        var e = i.call(c, a.id)(0),
        j = h(a, b) || e,
        k = f(a),
        l = g(a);
        return d.axis_rotated &amp;&amp; (0 &lt; a.value &amp;&amp; e &gt; l || a.value &lt; 0 &amp;&amp; l &gt; e) &amp;&amp; (l = e), [[k, l - (e - j)], [k, l - (e - j)], [k, l - (e - j)], [k, l - (e - j)]]
    }
}, i.lineWithRegions = function(a, b, c, d) {
    function e(a, b) {
        var c;
        for (c = 0; c &lt; b.length; c++)
        if (b[c].start &lt; a &amp;&amp; a &lt;= b[c].end)
        return !0;
        return !1
    }
    function f(a) {
        return &quot;M&quot; + a[0][0] + &quot; &quot; + a[0][1] + &quot; &quot; + a[1][0] + &quot; &quot; + a[1][1]
    }
    var g,
    h,
    i,
    j,
    k,
    l,
    m,
    n,
    o,
    r,
    s,
    t,
    u = this,
    v = u.config,
    w = -1,
    x = &quot;M&quot;,
    y = u.isCategorized() ? .5 : 0,
    z = [];
    if (q(d))
    for (g = 0; g &lt; d.length; g++)
    z[g] = {}, p(d[g].start) ? z[g].start = a[0].x : z[g].start = u.isTimeSeries() ? u.parseDate(d[g].start) : d[g].start, p(d[g].end) ? z[g].end = a[a.length - 1].x : z[g].end = u.isTimeSeries() ? u.parseDate(d[g].end) : d[g].end;
    for (s = v.axis_rotated ? function(a) {
        return c(a.value)
    } : function(a) {
        return b(a.x)
    }, t = v.axis_rotated ? function(a) {
        return b(a.x)
    } : function(a) {
        return c(a.value)
    }, i = u.isTimeSeries() ? function(a, d, e, g) {
        var h,
        i = a.x.getTime(),
        j = d.x - a.x,
        l = new Date(i + j * e),
        m = new Date(i + j * (e + g));
        return h = v.axis_rotated ? [[c(k(e)), b(l)], [c(k(e + g)), b(m)]] : [[b(l), c(k(e))], [b(m), c(k(e + g))]], f(h)
    } : function(a, d, e, g) {
        var h;
        return h = v.axis_rotated ? [[c(k(e), !0), b(j(e))], [c(k(e + g), !0), b(j(e + g))]] : [[b(j(e), !0), c(k(e))], [b(j(e + g), !0), c(k(e + g))]], f(h)
    }, g = 0; g &lt; a.length; g++) {
        if (p(z) || !e(a[g].x, z))
        x += &quot; &quot; + s(a[g]) + &quot; &quot; + t(a[g]);
        else
        for (j = u.getScale(a[g - 1].x + y, a[g].x + y, u.isTimeSeries()), k = u.getScale(a[g - 1].value, a[g].value), l = b(a[g].x) - b(a[g - 1].x), m = c(a[g].value) - c(a[g - 1].value), n = Math.sqrt(Math.pow(l, 2) + Math.pow(m, 2)), o = 2 / n, r = 2 * o, h = o; 1 &gt;= h; h += r)
        x += i(a[g - 1], a[g], h, o);
        w = a[g].x
    }
    return x
}, i.updateArea = function(a) {
    var b = this,
    c = b.d3;
    b.mainArea = b.main.selectAll(&quot;.&quot; + l.areas).selectAll(&quot;.&quot; + l.area).data(b.lineData.bind(b)), b.mainArea.enter().append(&quot;path&quot;).attr(&quot;class&quot;, b.classArea.bind(b)).style(&quot;fill&quot;, b.color).style(&quot;opacity&quot;, function() {
        return b.orgAreaOpacity = +c.select(this).style(&quot;opacity&quot;), 0
    }), b.mainArea.style(&quot;opacity&quot;, b.orgAreaOpacity), b.mainArea.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove()
}, i.redrawArea = function(a, b) {
    return [(b ? this.mainArea.transition(Math.random().toString()) : this.mainArea).attr(&quot;d&quot;, a).style(&quot;fill&quot;, this.color).style(&quot;opacity&quot;, this.orgAreaOpacity)]
}, i.generateDrawArea = function(a, b) {
    var c = this,
    d = c.config,
    e = c.d3.svg.area(),
    f = c.generateGetAreaPoints(a, b),
    g = b ? c.getSubYScale : c.getYScale,
    h = function(a) {
        return (b ? c.subxx : c.xx).call(c, a)
    },
    i = function(a, b) {
        return d.data_groups.length &gt; 0 ? f(a, b)[0][1] : g.call(c, a.id)(c.getAreaBaseValue(a.id))
    },
    j = function(a, b) {
        return d.data_groups.length &gt; 0 ? f(a, b)[1][1] : g.call(c, a.id)(a.value)
    };
    return e = d.axis_rotated ? e.x0(i).x1(j).y(h) : e.x(h).y0(d.area_above ? 0 : i).y1(j), d.line_connectNull || (e = e.defined(function(a) {
        return null !== a.value
    })), function(a) {
        var b,
        f = d.line_connectNull ? c.filterRemoveNull(a.values) : a.values,
        g = 0,
        h = 0;
        return c.isAreaType(a) ? (c.isStepType(a) &amp;&amp; (f = c.convertValuesToStep(f)), b = e.interpolate(c.getInterpolate(a))(f)) : (f[0] &amp;&amp; (g = c.x(f[0].x), h = c.getYScale(a.id)(f[0].value)), b = d.axis_rotated ? &quot;M &quot; + h + &quot; &quot; + g : &quot;M &quot; + g + &quot; &quot; + h), b ? b : &quot;M 0 0&quot;
    }
}, i.getAreaBaseValue = function() {
    return 0
}, i.generateGetAreaPoints = function(a, b) {
    var c = this,
    d = c.config,
    e = a.__max__ + 1,
    f = c.getShapeX(0, e, a, !!b),
    g = c.getShapeY(!!b),
    h = c.getShapeOffset(c.isAreaType, a, !!b),
    i = b ? c.getSubYScale : c.getYScale;
    return function(a, b) {
        var e = i.call(c, a.id)(0),
        j = h(a, b) || e,
        k = f(a),
        l = g(a);
        return d.axis_rotated &amp;&amp; (0 &lt; a.value &amp;&amp; e &gt; l || a.value &lt; 0 &amp;&amp; l &gt; e) &amp;&amp; (l = e), [[k, j], [k, l - (e - j)], [k, l - (e - j)], [k, j]]
    }
}, i.updateCircle = function() {
    var a = this;
    a.mainCircle = a.main.selectAll(&quot;.&quot; + l.circles).selectAll(&quot;.&quot; + l.circle).data(a.lineOrScatterData.bind(a)), a.mainCircle.enter().append(&quot;circle&quot;).attr(&quot;class&quot;, a.classCircle.bind(a)).attr(&quot;r&quot;, a.pointR.bind(a)).style(&quot;fill&quot;, a.color), a.mainCircle.style(&quot;opacity&quot;, a.initialOpacityForCircle.bind(a)), a.mainCircle.exit().remove()
}, i.redrawCircle = function(a, b, c) {
    var d = this.main.selectAll(&quot;.&quot; + l.selectedCircle);
    return [(c ? this.mainCircle.transition(Math.random().toString()) : this.mainCircle).style(&quot;opacity&quot;, this.opacityForCircle.bind(this)).style(&quot;fill&quot;, this.color).attr(&quot;cx&quot;, a).attr(&quot;cy&quot;, b), (c ? d.transition(Math.random().toString()) : d).attr(&quot;cx&quot;, a).attr(&quot;cy&quot;, b)]
}, i.circleX = function(a) {
    return a.x || 0 === a.x ? this.x(a.x) : null
}, i.updateCircleY = function() {
    var a,
    b,
    c = this;
    c.config.data_groups.length &gt; 0 ? (a = c.getShapeIndices(c.isLineType), b = c.generateGetLinePoints(a), c.circleY = function(a, c) {
        return b(a, c)[0][1]
    }) : c.circleY = function(a) {
        return c.getYScale(a.id)(a.value)
    }
}, i.getCircles = function(a, b) {
    var c = this;
    return (b ? c.main.selectAll(&quot;.&quot; + l.circles + c.getTargetSelectorSuffix(b)) : c.main).selectAll(&quot;.&quot; + l.circle + (m(a) ? &quot;-&quot; + a : &quot;&quot;))
}, i.expandCircles = function(a, b, c) {
    var d = this,
    e = d.pointExpandedR.bind(d);
    c &amp;&amp; d.unexpandCircles(), d.getCircles(a, b).classed(l.EXPANDED, !0).attr(&quot;r&quot;, e)
}, i.unexpandCircles = function(a) {
    var b = this,
    c = b.pointR.bind(b);
    b.getCircles(a).filter(function() {
        return b.d3.select(this).classed(l.EXPANDED)
    }).classed(l.EXPANDED, !1).attr(&quot;r&quot;, c)
}, i.pointR = function(a) {
    var b = this,
    c = b.config;
    return b.isStepType(a) ? 0 : n(c.point_r) ? c.point_r(a) : c.point_r;
}, i.pointExpandedR = function(a) {
    var b = this,
    c = b.config;
    return c.point_focus_expand_enabled ? c.point_focus_expand_r ? c.point_focus_expand_r : 1.75 * b.pointR(a) : b.pointR(a)
}, i.pointSelectR = function(a) {
    var b = this,
    c = b.config;
    return n(c.point_select_r) ? c.point_select_r(a) : c.point_select_r ? c.point_select_r : 4 * b.pointR(a)
}, i.isWithinCircle = function(a, b) {
    var c = this.d3,
    d = c.mouse(a),
    e = c.select(a),
    f = +e.attr(&quot;cx&quot;),
    g = +e.attr(&quot;cy&quot;);
    return Math.sqrt(Math.pow(f - d[0], 2) + Math.pow(g - d[1], 2)) &lt; b
}, i.isWithinStep = function(a, b) {
    return Math.abs(b - this.d3.mouse(a)[1]) &lt; 30
}, i.initBar = function() {
    var a = this;
    a.main.select(&quot;.&quot; + l.chart).append(&quot;g&quot;).attr(&quot;class&quot;, l.chartBars)
}, i.updateTargetsForBar = function(a) {
    var b,
    c,
    d = this,
    e = d.config,
    f = d.classChartBar.bind(d),
    g = d.classBars.bind(d),
    h = d.classFocus.bind(d);
    b = d.main.select(&quot;.&quot; + l.chartBars).selectAll(&quot;.&quot; + l.chartBar).data(a).attr(&quot;class&quot;, function(a) {
        return f(a) + h(a)
    }), c = b.enter().append(&quot;g&quot;).attr(&quot;class&quot;, f).style(&quot;opacity&quot;, 0).style(&quot;pointer-events&quot;, &quot;none&quot;), c.append(&quot;g&quot;).attr(&quot;class&quot;, g).style(&quot;cursor&quot;, function(a) {
        return e.data_selection_isselectable(a) ? &quot;pointer&quot; : null
    })
}, i.updateBar = function(a) {
    var b = this,
    c = b.barData.bind(b),
    d = b.classBar.bind(b),
    e = b.initialOpacity.bind(b),
    f = function(a) {
        return b.color(a.id)
    };
    b.mainBar = b.main.selectAll(&quot;.&quot; + l.bars).selectAll(&quot;.&quot; + l.bar).data(c), b.mainBar.enter().append(&quot;path&quot;).attr(&quot;class&quot;, d).style(&quot;stroke&quot;, f).style(&quot;fill&quot;, f), b.mainBar.style(&quot;opacity&quot;, e), b.mainBar.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove()
}, i.redrawBar = function(a, b) {
    return [(b ? this.mainBar.transition(Math.random().toString()) : this.mainBar).attr(&quot;d&quot;, a).style(&quot;fill&quot;, this.color).style(&quot;opacity&quot;, 1)]
}, i.getBarW = function(a, b) {
    var c = this,
    d = c.config,
    e = &quot;number&quot; == typeof d.bar_width ? d.bar_width : b ? a.tickInterval() * d.bar_width_ratio / b : 0;
    return d.bar_width_max &amp;&amp; e &gt; d.bar_width_max ? d.bar_width_max : e
}, i.getBars = function(a, b) {
    var c = this;
    return (b ? c.main.selectAll(&quot;.&quot; + l.bars + c.getTargetSelectorSuffix(b)) : c.main).selectAll(&quot;.&quot; + l.bar + (m(a) ? &quot;-&quot; + a : &quot;&quot;))
}, i.expandBars = function(a, b, c) {
    var d = this;
    c &amp;&amp; d.unexpandBars(), d.getBars(a, b).classed(l.EXPANDED, !0)
}, i.unexpandBars = function(a) {
    var b = this;
    b.getBars(a).classed(l.EXPANDED, !1)
}, i.generateDrawBar = function(a, b) {
    var c = this,
    d = c.config,
    e = c.generateGetBarPoints(a, b);
    return function(a, b) {
        var c = e(a, b),
        f = d.axis_rotated ? 1 : 0,
        g = d.axis_rotated ? 0 : 1,
        h = &quot;M &quot; + c[0][f] + &quot;,&quot; + c[0][g] + &quot; L&quot; + c[1][f] + &quot;,&quot; + c[1][g] + &quot; L&quot; + c[2][f] + &quot;,&quot; + c[2][g] + &quot; L&quot; + c[3][f] + &quot;,&quot; + c[3][g] + &quot; z&quot;;
        return h
    }
}, i.generateGetBarPoints = function(a, b) {
    var c = this,
    d = b ? c.subXAxis : c.xAxis,
    e = a.__max__ + 1,
    f = c.getBarW(d, e),
    g = c.getShapeX(f, e, a, !!b),
    h = c.getShapeY(!!b),
    i = c.getShapeOffset(c.isBarType, a, !!b),
    j = b ? c.getSubYScale : c.getYScale;
    return function(a, b) {
        var d = j.call(c, a.id)(0),
        e = i(a, b) || d,
        k = g(a),
        l = h(a);
        return c.config.axis_rotated &amp;&amp; (0 &lt; a.value &amp;&amp; d &gt; l || a.value &lt; 0 &amp;&amp; l &gt; d) &amp;&amp; (l = d), [[k, e], [k, l - (d - e)], [k + f, l - (d - e)], [k + f, e]]
    }
}, i.isWithinBar = function(a) {
    var b = this.d3.mouse(a),
    c = a.getBoundingClientRect(),
    d = a.pathSegList.getItem(0),
    e = a.pathSegList.getItem(1),
    f = Math.min(d.x, e.x),
    g = Math.min(d.y, e.y),
    h = c.width,
    i = c.height,
    j = 2,
    k = f - j,
    l = f + h + j,
    m = g + i + j,
    n = g - j;
    return k &lt; b[0] &amp;&amp; b[0] &lt; l &amp;&amp; n &lt; b[1] &amp;&amp; b[1] &lt; m
}, i.initText = function() {
    var a = this;
    a.main.select(&quot;.&quot; + l.chart).append(&quot;g&quot;).attr(&quot;class&quot;, l.chartTexts), a.mainText = a.d3.selectAll([])
}, i.updateTargetsForText = function(a) {
    var b,
    c,
    d = this,
    e = d.classChartText.bind(d),
    f = d.classTexts.bind(d),
    g = d.classFocus.bind(d);
    b = d.main.select(&quot;.&quot; + l.chartTexts).selectAll(&quot;.&quot; + l.chartText).data(a).attr(&quot;class&quot;, function(a) {
        return e(a) + g(a)
    }), c = b.enter().append(&quot;g&quot;).attr(&quot;class&quot;, e).style(&quot;opacity&quot;, 0).style(&quot;pointer-events&quot;, &quot;none&quot;), c.append(&quot;g&quot;).attr(&quot;class&quot;, f)
}, i.updateText = function(a) {
    var b = this,
    c = b.config,
    d = b.barOrLineData.bind(b),
    e = b.classText.bind(b);
    b.mainText = b.main.selectAll(&quot;.&quot; + l.texts).selectAll(&quot;.&quot; + l.text).data(d), b.mainText.enter().append(&quot;text&quot;).attr(&quot;class&quot;, e).attr(&quot;text-anchor&quot;, function(a) {
        return c.axis_rotated ? a.value &lt; 0 ? &quot;end&quot; : &quot;start&quot; : &quot;middle&quot;
    }).style(&quot;stroke&quot;, &quot;none&quot;).style(&quot;fill&quot;, function(a) {
        return b.color(a)
    }).style(&quot;fill-opacity&quot;, 0), b.mainText.text(function(a, c, d) {
        return b.dataLabelFormat(a.id)(a.value, a.id, c, d)
    }), b.mainText.exit().transition().duration(a).style(&quot;fill-opacity&quot;, 0).remove()
}, i.redrawText = function(a, b, c, d) {
    return [(d ? this.mainText.transition() : this.mainText).attr(&quot;x&quot;, a).attr(&quot;y&quot;, b).style(&quot;fill&quot;, this.color).style(&quot;fill-opacity&quot;, c ? 0 : this.opacityForText.bind(this))]
}, i.getTextRect = function(a, b, c) {
    var d,
    e = this.d3.select(&quot;body&quot;).append(&quot;div&quot;).classed(&quot;c3&quot;, !0),
    f = e.append(&quot;svg&quot;).style(&quot;visibility&quot;, &quot;hidden&quot;).style(&quot;position&quot;, &quot;fixed&quot;).style(&quot;top&quot;, 0).style(&quot;left&quot;, 0),
    g = this.d3.select(c).style(&quot;font&quot;);
    return f.selectAll(&quot;.dummy&quot;).data([a]).enter().append(&quot;text&quot;).classed(b ? b : &quot;&quot;, !0).style(&quot;font&quot;, g).text(a).each(function() {
        d = this.getBoundingClientRect()
    }), e.remove(), d
}, i.generateXYForText = function(a, b, c, d) {
    var e = this,
    f = e.generateGetAreaPoints(a, !1),
    g = e.generateGetBarPoints(b, !1),
    h = e.generateGetLinePoints(c, !1),
    i = d ? e.getXForText : e.getYForText;
    return function(a, b) {
        var c = e.isAreaType(a) ? f : e.isBarType(a) ? g : h;
        return i.call(e, c(a, b), a, this)
    }
}, i.getXForText = function(a, b, c) {
    var d,
    e,
    f = this,
    g = c.getBoundingClientRect();
    return f.config.axis_rotated ? (e = f.isBarType(b) ? 4 : 6, d = a[2][1] + e * (b.value &lt; 0 ? -1 : 1)) : d = f.hasType(&quot;bar&quot;) ? (a[2][0] + a[0][0]) / 2 : a[0][0], null === b.value &amp;&amp; (d &gt; f.width ? d = f.width - g.width : 0 &gt; d &amp;&amp; (d = 4)), d
}, i.getYForText = function(a, b, c) {
    var d,
    e = this,
    f = c.getBoundingClientRect();
    return e.config.axis_rotated ? d = (a[0][0] + a[2][0] + .6 * f.height) / 2 : (d = a[2][1], b.value &lt; 0 || 0 === b.value &amp;&amp; !e.hasPositiveValue ? (d += f.height, e.isBarType(b) &amp;&amp; e.isSafari() ? d -= 3 : !e.isBarType(b) &amp;&amp; e.isChrome() &amp;&amp; (d += 3)) : d += e.isBarType(b) ? -3 : -6), null !== b.value || e.config.axis_rotated || (d &lt; f.height ? d = f.height : d &gt; this.height &amp;&amp; (d = this.height - 4)), d
}, i.setTargetType = function(a, b) {
    var c = this,
    d = c.config;
    c.mapToTargetIds(a).forEach(function(a) {
        c.withoutFadeIn[a] = b === d.data_types[a], d.data_types[a] = b
    }), a || (d.data_type = b)
}, i.hasType = function(a, b) {
    var c = this,
    d = c.config.data_types,
    e = !1;
    return b = b || c.data.targets, b &amp;&amp; b.length ? b.forEach(function(b) {
        var c = d[b.id];
        (c &amp;&amp; c.indexOf(a) &gt;= 0 || !c &amp;&amp; &quot;line&quot; === a) &amp;&amp; (e = !0)
    }) : Object.keys(d).length ? Object.keys(d).forEach(function(b) {
        d[b] === a &amp;&amp; (e = !0)
    }) : e = c.config.data_type === a, e
}, i.hasArcType = function(a) {
    return this.hasType(&quot;pie&quot;, a) || this.hasType(&quot;donut&quot;, a) || this.hasType(&quot;gauge&quot;, a)
}, i.isLineType = function(a) {
    var b = this.config,
    c = o(a) ? a : a.id;
    return !b.data_types[c] || [&quot;line&quot;, &quot;spline&quot;, &quot;area&quot;, &quot;area-spline&quot;, &quot;step&quot;, &quot;area-step&quot;].indexOf(b.data_types[c]) &gt;= 0
}, i.isStepType = function(a) {
    var b = o(a) ? a : a.id;
    return [&quot;step&quot;, &quot;area-step&quot;].indexOf(this.config.data_types[b]) &gt;= 0
}, i.isSplineType = function(a) {
    var b = o(a) ? a : a.id;
    return [&quot;spline&quot;, &quot;area-spline&quot;].indexOf(this.config.data_types[b]) &gt;= 0
}, i.isAreaType = function(a) {
    var b = o(a) ? a : a.id;
    return [&quot;area&quot;, &quot;area-spline&quot;, &quot;area-step&quot;].indexOf(this.config.data_types[b]) &gt;= 0
}, i.isBarType = function(a) {
    var b = o(a) ? a : a.id;
    return &quot;bar&quot; === this.config.data_types[b]
}, i.isScatterType = function(a) {
    var b = o(a) ? a : a.id;
    return &quot;scatter&quot; === this.config.data_types[b]
}, i.isPieType = function(a) {
    var b = o(a) ? a : a.id;
    return &quot;pie&quot; === this.config.data_types[b]
}, i.isGaugeType = function(a) {
    var b = o(a) ? a : a.id;
    return &quot;gauge&quot; === this.config.data_types[b]
}, i.isDonutType = function(a) {
    var b = o(a) ? a : a.id;
    return &quot;donut&quot; === this.config.data_types[b]
}, i.isArcType = function(a) {
    return this.isPieType(a) || this.isDonutType(a) || this.isGaugeType(a)
}, i.lineData = function(a) {
    return this.isLineType(a) ? [a] : []
}, i.arcData = function(a) {
    return this.isArcType(a.data) ? [a] : []
}, i.barData = function(a) {
    return this.isBarType(a) ? a.values : []
}, i.lineOrScatterData = function(a) {
    return this.isLineType(a) || this.isScatterType(a) ? a.values : []
}, i.barOrLineData = function(a) {
    return this.isBarType(a) || this.isLineType(a) ? a.values : []
}, i.isInterpolationType = function(a) {
    return [&quot;linear&quot;, &quot;linear-closed&quot;, &quot;basis&quot;, &quot;basis-open&quot;, &quot;basis-closed&quot;, &quot;bundle&quot;, &quot;cardinal&quot;, &quot;cardinal-open&quot;, &quot;cardinal-closed&quot;, &quot;monotone&quot;].indexOf(a) &gt;= 0
}, i.initGrid = function() {
    var a = this,
    b = a.config,
    c = a.d3;
    a.grid = a.main.append(&quot;g&quot;).attr(&quot;clip-path&quot;, a.clipPathForGrid).attr(&quot;class&quot;, l.grid), b.grid_x_show &amp;&amp; a.grid.append(&quot;g&quot;).attr(&quot;class&quot;, l.xgrids), b.grid_y_show &amp;&amp; a.grid.append(&quot;g&quot;).attr(&quot;class&quot;, l.ygrids), b.grid_focus_show &amp;&amp; a.grid.append(&quot;g&quot;).attr(&quot;class&quot;, l.xgridFocus).append(&quot;line&quot;).attr(&quot;class&quot;, l.xgridFocus), a.xgrid = c.selectAll([]), b.grid_lines_front || a.initGridLines()
}, i.initGridLines = function() {
    var a = this,
    b = a.d3;
    a.gridLines = a.main.append(&quot;g&quot;).attr(&quot;clip-path&quot;, a.clipPathForGrid).attr(&quot;class&quot;, l.grid + &quot; &quot; + l.gridLines), a.gridLines.append(&quot;g&quot;).attr(&quot;class&quot;, l.xgridLines), a.gridLines.append(&quot;g&quot;).attr(&quot;class&quot;, l.ygridLines), a.xgridLines = b.selectAll([])
}, i.updateXGrid = function(a) {
    var b = this,
    c = b.config,
    d = b.d3,
    e = b.generateGridData(c.grid_x_type, b.x),
    f = b.isCategorized() ? b.xAxis.tickOffset() : 0;
    b.xgridAttr = c.axis_rotated ? {
        x1: 0,
        x2: b.width,
        y1: function(a) {
            return b.x(a) - f
        },
        y2: function(a) {
            return b.x(a) - f
        }
    } : {
        x1: function(a) {
            return b.x(a) + f
        },
        x2: function(a) {
            return b.x(a) + f
        },
        y1: 0,
        y2: b.height
    }, b.xgrid = b.main.select(&quot;.&quot; + l.xgrids).selectAll(&quot;.&quot; + l.xgrid).data(e), b.xgrid.enter().append(&quot;line&quot;).attr(&quot;class&quot;, l.xgrid), a || b.xgrid.attr(b.xgridAttr).style(&quot;opacity&quot;, function() {
        return +d.select(this).attr(c.axis_rotated ? &quot;y1&quot; : &quot;x1&quot;) === (c.axis_rotated ? b.height : 0) ? 0 : 1
    }), b.xgrid.exit().remove()
}, i.updateYGrid = function() {
    var a = this,
    b = a.config,
    c = a.yAxis.tickValues() || a.y.ticks(b.grid_y_ticks);
    a.ygrid = a.main.select(&quot;.&quot; + l.ygrids).selectAll(&quot;.&quot; + l.ygrid).data(c), a.ygrid.enter().append(&quot;line&quot;).attr(&quot;class&quot;, l.ygrid), a.ygrid.attr(&quot;x1&quot;, b.axis_rotated ? a.y : 0).attr(&quot;x2&quot;, b.axis_rotated ? a.y : a.width).attr(&quot;y1&quot;, b.axis_rotated ? 0 : a.y).attr(&quot;y2&quot;, b.axis_rotated ? a.height : a.y), a.ygrid.exit().remove(), a.smoothLines(a.ygrid, &quot;grid&quot;)
}, i.gridTextAnchor = function(a) {
    return a.position ? a.position : &quot;end&quot;
}, i.gridTextDx = function(a) {
    return &quot;start&quot; === a.position ? 4 : &quot;middle&quot; === a.position ? 0 : -4
}, i.xGridTextX = function(a) {
    return &quot;start&quot; === a.position ? -this.height : &quot;middle&quot; === a.position ? -this.height / 2 : 0
}, i.yGridTextX = function(a) {
    return &quot;start&quot; === a.position ? 0 : &quot;middle&quot; === a.position ? this.width / 2 : this.width
}, i.updateGrid = function(a) {
    var b,
    c,
    d,
    e = this,
    f = e.main,
    g = e.config;
    e.grid.style(&quot;visibility&quot;, e.hasArcType() ? &quot;hidden&quot; : &quot;visible&quot;), f.select(&quot;line.&quot; + l.xgridFocus).style(&quot;visibility&quot;, &quot;hidden&quot;), g.grid_x_show &amp;&amp; e.updateXGrid(), e.xgridLines = f.select(&quot;.&quot; + l.xgridLines).selectAll(&quot;.&quot; + l.xgridLine).data(g.grid_x_lines), b = e.xgridLines.enter().append(&quot;g&quot;).attr(&quot;class&quot;, function(a) {
        return l.xgridLine + (a[&quot;class&quot;] ? &quot; &quot; + a[&quot;class&quot;] : &quot;&quot;)
    }), b.append(&quot;line&quot;).style(&quot;opacity&quot;, 0), b.append(&quot;text&quot;).attr(&quot;text-anchor&quot;, e.gridTextAnchor).attr(&quot;transform&quot;, g.axis_rotated ? &quot;&quot; : &quot;rotate(-90)&quot;).attr(&quot;dx&quot;, e.gridTextDx).attr(&quot;dy&quot;, -5).style(&quot;opacity&quot;, 0), e.xgridLines.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove(), g.grid_y_show &amp;&amp; e.updateYGrid(), e.ygridLines = f.select(&quot;.&quot; + l.ygridLines).selectAll(&quot;.&quot; + l.ygridLine).data(g.grid_y_lines), c = e.ygridLines.enter().append(&quot;g&quot;).attr(&quot;class&quot;, function(a) {
        return l.ygridLine + (a[&quot;class&quot;] ? &quot; &quot; + a[&quot;class&quot;] : &quot;&quot;)
    }), c.append(&quot;line&quot;).style(&quot;opacity&quot;, 0), c.append(&quot;text&quot;).attr(&quot;text-anchor&quot;, e.gridTextAnchor).attr(&quot;transform&quot;, g.axis_rotated ? &quot;rotate(-90)&quot; : &quot;&quot;).attr(&quot;dx&quot;, e.gridTextDx).attr(&quot;dy&quot;, -5).style(&quot;opacity&quot;, 0), d = e.yv.bind(e), e.ygridLines.select(&quot;line&quot;).transition().duration(a).attr(&quot;x1&quot;, g.axis_rotated ? d : 0).attr(&quot;x2&quot;, g.axis_rotated ? d : e.width).attr(&quot;y1&quot;, g.axis_rotated ? 0 : d).attr(&quot;y2&quot;, g.axis_rotated ? e.height : d).style(&quot;opacity&quot;, 1), e.ygridLines.select(&quot;text&quot;).transition().duration(a).attr(&quot;x&quot;, g.axis_rotated ? e.xGridTextX.bind(e) : e.yGridTextX.bind(e)).attr(&quot;y&quot;, d).text(function(a) {
        return a.text
    }).style(&quot;opacity&quot;, 1), e.ygridLines.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove()
}, i.redrawGrid = function(a) {
    var b = this,
    c = b.config,
    d = b.xv.bind(b),
    e = b.xgridLines.select(&quot;line&quot;),
    f = b.xgridLines.select(&quot;text&quot;);
    return [(a ? e.transition() : e).attr(&quot;x1&quot;, c.axis_rotated ? 0 : d).attr(&quot;x2&quot;, c.axis_rotated ? b.width : d).attr(&quot;y1&quot;, c.axis_rotated ? d : 0).attr(&quot;y2&quot;, c.axis_rotated ? d : b.height).style(&quot;opacity&quot;, 1), (a ? f.transition() : f).attr(&quot;x&quot;, c.axis_rotated ? b.yGridTextX.bind(b) : b.xGridTextX.bind(b)).attr(&quot;y&quot;, d).text(function(a) {
        return a.text
    }).style(&quot;opacity&quot;, 1)]
}, i.showXGridFocus = function(a) {
    var b = this,
    c = b.config,
    d = a.filter(function(a) {
        return a &amp;&amp; m(a.value)
    }),
    e = b.main.selectAll(&quot;line.&quot; + l.xgridFocus),
    f = b.xx.bind(b);
    c.tooltip_show &amp;&amp; (b.hasType(&quot;scatter&quot;) || b.hasArcType() || (e.style(&quot;visibility&quot;, &quot;visible&quot;).data([d[0]]).attr(c.axis_rotated ? &quot;y1&quot; : &quot;x1&quot;, f).attr(c.axis_rotated ? &quot;y2&quot; : &quot;x2&quot;, f), b.smoothLines(e, &quot;grid&quot;)))
}, i.hideXGridFocus = function() {
    this.main.select(&quot;line.&quot; + l.xgridFocus).style(&quot;visibility&quot;, &quot;hidden&quot;)
}, i.updateXgridFocus = function() {
    var a = this,
    b = a.config;
    a.main.select(&quot;line.&quot; + l.xgridFocus).attr(&quot;x1&quot;, b.axis_rotated ? 0 : -10).attr(&quot;x2&quot;, b.axis_rotated ? a.width : -10).attr(&quot;y1&quot;, b.axis_rotated ? -10 : 0).attr(&quot;y2&quot;, b.axis_rotated ? -10 : a.height)
}, i.generateGridData = function(a, b) {
    var c,
    d,
    e,
    f,
    g = this,
    h = [],
    i = g.main.select(&quot;.&quot; + l.axisX).selectAll(&quot;.tick&quot;).size();
    if (&quot;year&quot; === a)
    for (c = g.getXDomain(), d = c[0].getFullYear(), e = c[1].getFullYear(), f = d; e &gt;= f; f++)
    h.push(new Date(f + &quot;-01-01 00:00:00&quot;));
    else
    h = b.ticks(10), h.length &gt; i &amp;&amp; (h = h.filter(function(a) {
        return (&quot;&quot; + a).indexOf(&quot;.&quot;) &lt; 0
    }));
    return h
}, i.getGridFilterToRemove = function(a) {
    return a ? function(b) {
        var c = !1;
        return [].concat(a).forEach(function(a) {
            (&quot;value&quot; in a &amp;&amp; b.value === a.value || &quot;class&quot; in a &amp;&amp; b[&quot;class&quot;] === a[&quot;class&quot;]) &amp;&amp; (c = !0)
        }), c
    } : function() {
        return !0
    }
}, i.removeGridLines = function(a, b) {
    var c = this,
    d = c.config,
    e = c.getGridFilterToRemove(a),
    f = function(a) {
        return !e(a)
    },
    g = b ? l.xgridLines : l.ygridLines,
    h = b ? l.xgridLine : l.ygridLine;
    c.main.select(&quot;.&quot; + g).selectAll(&quot;.&quot; + h).filter(e).transition().duration(d.transition_duration).style(&quot;opacity&quot;, 0).remove(), b ? d.grid_x_lines = d.grid_x_lines.filter(f) : d.grid_y_lines = d.grid_y_lines.filter(f)
}, i.initTooltip = function() {
    var a,
    b = this,
    c = b.config;
    if (b.tooltip = b.selectChart.style(&quot;position&quot;, &quot;relative&quot;).append(&quot;div&quot;).attr(&quot;class&quot;, l.tooltipContainer).style(&quot;position&quot;, &quot;absolute&quot;).style(&quot;pointer-events&quot;, &quot;none&quot;).style(&quot;display&quot;, &quot;none&quot;), c.tooltip_init_show) {
        if (b.isTimeSeries() &amp;&amp; o(c.tooltip_init_x)) {
            for (c.tooltip_init_x = b.parseDate(c.tooltip_init_x), a = 0; a &lt; b.data.targets[0].values.length &amp;&amp; b.data.targets[0].values[a].x - c.tooltip_init_x !== 0; a++)
            ;
            c.tooltip_init_x = a
        }
        b.tooltip.html(c.tooltip_contents.call(b, b.data.targets.map(function(a) {
            return b.addName(a.values[c.tooltip_init_x])
        }), b.axis.getXAxisTickFormat(), b.getYFormat(b.hasArcType()), b.color)), b.tooltip.style(&quot;top&quot;, c.tooltip_init_position.top).style(&quot;left&quot;, c.tooltip_init_position.left).style(&quot;display&quot;, &quot;block&quot;)
    }
}, i.getTooltipContent = function(a, b, c, d) {
    var e,
    f,
    g,
    h,
    i,
    j,
    k = this,
    l = k.config,
    m = l.tooltip_format_title || b,
    n = l.tooltip_format_name || function(a) {
        return a
    },
    o = l.tooltip_format_value || c,
    p = k.isOrderAsc();
    if (0 === l.data_groups.length)
    a.sort(function(a, b) {
        var c = a ? a.value : null,
        d = b ? b.value : null;
        return p ? c - d : d - c
    });
    else {
        var q = k.orderTargets(k.data.targets).map(function(a) {
            return a.id
        });
        a.sort(function(a, b) {
            var c = a ? a.value : null,
            d = b ? b.value : null;
            return c &gt; 0 &amp;&amp; d &gt; 0 &amp;&amp; (c = a ? q.indexOf(a.id) : null, d = b ? q.indexOf(b.id) : null), p ? c - d : d - c
        })
    }
    for (f = 0; f &lt; a.length; f++)
    if (a[f] &amp;&amp; (a[f].value || 0 === a[f].value) &amp;&amp; (e || (g = y(m ? m(a[f].x) : a[f].x), e = &quot;&lt;table class=&#39;&quot; + k.CLASS.tooltip + &quot;&#39;&gt;&quot; + (g || 0 === g ? &quot;&lt;tr&gt;&lt;th colspan=&#39;2&#39;&gt;&quot; + g + &quot;&lt;/th&gt;&lt;/tr&gt;&quot; : &quot;&quot;)), h = y(o(a[f].value, a[f].ratio, a[f].id, a[f].index, a)), void 0 !== h)) {
        if (null === a[f].name)
        continue;
        i = y(n(a[f].name, a[f].ratio, a[f].id, a[f].index)), j = k.levelColor ? k.levelColor(a[f].value) : d(a[f].id), e += &quot;&lt;tr class=&#39;&quot; + k.CLASS.tooltipName + &quot;-&quot; + k.getTargetSelectorSuffix(a[f].id) + &quot;&#39;&gt;&quot;, e += &quot;&lt;td class=&#39;name&#39;&gt;&lt;span style=&#39;background-color:&quot; + j + &quot;&#39;&gt;&lt;/span&gt;&quot; + i + &quot;&lt;/td&gt;&quot;, e += &quot;&lt;td class=&#39;value&#39;&gt;&quot; + h + &quot;&lt;/td&gt;&quot;, e += &quot;&lt;/tr&gt;&quot;
    }
    return e + &quot;&lt;/table&gt;&quot;
}, i.tooltipPosition = function(a, b, c, d) {
    var e,
    f,
    g,
    h,
    i,
    j = this,
    k = j.config,
    l = j.d3,
    m = j.hasArcType(),
    n = l.mouse(d);
    return m ? (f = (j.width - (j.isLegendRight ? j.getLegendWidth() : 0)) / 2 + n[0], h = j.height / 2 + n[1] + 20) : (e = j.getSvgLeft(!0), k.axis_rotated ? (f = e + n[0] + 100, g = f + b, i = j.currentWidth - j.getCurrentPaddingRight(), h = j.x(a[0].x) + 20) : (f = e + j.getCurrentPaddingLeft(!0) + j.x(a[0].x) + 20, g = f + b, i = e + j.currentWidth - j.getCurrentPaddingRight(), h = n[1] + 15), g &gt; i &amp;&amp; (f -= g - i + 20), h + c &gt; j.currentHeight &amp;&amp; (h -= c + 30)), 0 &gt; h &amp;&amp; (h = 0), {
        top: h,
        left: f
    }
}, i.showTooltip = function(a, b) {
    var c,
    d,
    e,
    f = this,
    g = f.config,
    h = f.hasArcType(),
    j = a.filter(function(a) {
        return a &amp;&amp; m(a.value)
    }),
    k = g.tooltip_position || i.tooltipPosition;
    0 !== j.length &amp;&amp; g.tooltip_show &amp;&amp; (f.tooltip.html(g.tooltip_contents.call(f, a, f.axis.getXAxisTickFormat(), f.getYFormat(h), f.color)).style(&quot;display&quot;, &quot;block&quot;), c = f.tooltip.property(&quot;offsetWidth&quot;), d = f.tooltip.property(&quot;offsetHeight&quot;), e = k.call(this, j, c, d, b), f.tooltip.style(&quot;top&quot;, e.top + &quot;px&quot;).style(&quot;left&quot;, e.left + &quot;px&quot;))
}, i.hideTooltip = function() {
    this.tooltip.style(&quot;display&quot;, &quot;none&quot;)
}, i.initLegend = function() {
    var a = this;
    return a.legendItemTextBox = {}, a.legendHasRendered = !1, a.legend = a.svg.append(&quot;g&quot;).attr(&quot;transform&quot;, a.getTranslate(&quot;legend&quot;)), a.config.legend_show ? void a.updateLegendWithDefaults() : (a.legend.style(&quot;visibility&quot;, &quot;hidden&quot;), void (a.hiddenLegendIds = a.mapToIds(a.data.targets)))
}, i.updateLegendWithDefaults = function() {
    var a = this;
    a.updateLegend(a.mapToIds(a.data.targets), {
        withTransform: !1,
        withTransitionForTransform: !1,
        withTransition: !1
    })
}, i.updateSizeForLegend = function(a, b) {
    var c = this,
    d = c.config,
    e = {
        top: c.isLegendTop ? c.getCurrentPaddingTop() + d.legend_inset_y + 5.5 : c.currentHeight - a - c.getCurrentPaddingBottom() - d.legend_inset_y,
        left: c.isLegendLeft ? c.getCurrentPaddingLeft() + d.legend_inset_x + .5 : c.currentWidth - b - c.getCurrentPaddingRight() - d.legend_inset_x + .5
    };
    c.margin3 = {
        top: c.isLegendRight ? 0 : c.isLegendInset ? e.top : c.currentHeight - a,
        right: NaN,
        bottom: 0,
        left: c.isLegendRight ? c.currentWidth - b : c.isLegendInset ? e.left : 0
    }
}, i.transformLegend = function(a) {
    var b = this;
    (a ? b.legend.transition() : b.legend).attr(&quot;transform&quot;, b.getTranslate(&quot;legend&quot;))
}, i.updateLegendStep = function(a) {
    this.legendStep = a
}, i.updateLegendItemWidth = function(a) {
    this.legendItemWidth = a
}, i.updateLegendItemHeight = function(a) {
    this.legendItemHeight = a
}, i.getLegendWidth = function() {
    var a = this;
    return a.config.legend_show ? a.isLegendRight || a.isLegendInset ? a.legendItemWidth * (a.legendStep + 1) : a.currentWidth : 0
}, i.getLegendHeight = function() {
    var a = this,
    b = 0;
    return a.config.legend_show &amp;&amp; (b = a.isLegendRight ? a.currentHeight : Math.max(20, a.legendItemHeight) * (a.legendStep + 1)), b
}, i.opacityForLegend = function(a) {
    return a.classed(l.legendItemHidden) ? null : 1
}, i.opacityForUnfocusedLegend = function(a) {
    return a.classed(l.legendItemHidden) ? null : .3
}, i.toggleFocusLegend = function(a, b) {
    var c = this;
    a = c.mapToTargetIds(a), c.legend.selectAll(&quot;.&quot; + l.legendItem).filter(function(b) {
        return a.indexOf(b) &gt;= 0
    }).classed(l.legendItemFocused, b).transition().duration(100).style(&quot;opacity&quot;, function() {
        var a = b ? c.opacityForLegend : c.opacityForUnfocusedLegend;
        return a.call(c, c.d3.select(this))
    })
}, i.revertLegend = function() {
    var a = this,
    b = a.d3;
    a.legend.selectAll(&quot;.&quot; + l.legendItem).classed(l.legendItemFocused, !1).transition().duration(100).style(&quot;opacity&quot;, function() {
        return a.opacityForLegend(b.select(this))
    })
}, i.showLegend = function(a) {
    var b = this,
    c = b.config;
    c.legend_show || (c.legend_show = !0, b.legend.style(&quot;visibility&quot;, &quot;visible&quot;), b.legendHasRendered || b.updateLegendWithDefaults()), b.removeHiddenLegendIds(a), b.legend.selectAll(b.selectorLegends(a)).style(&quot;visibility&quot;, &quot;visible&quot;).transition().style(&quot;opacity&quot;, function() {
        return b.opacityForLegend(b.d3.select(this))
    })
}, i.hideLegend = function(a) {
    var b = this,
    c = b.config;
    c.legend_show &amp;&amp; u(a) &amp;&amp; (c.legend_show = !1, b.legend.style(&quot;visibility&quot;, &quot;hidden&quot;)), b.addHiddenLegendIds(a), b.legend.selectAll(b.selectorLegends(a)).style(&quot;opacity&quot;, 0).style(&quot;visibility&quot;, &quot;hidden&quot;)
}, i.clearLegendItemTextBoxCache = function() {
    this.legendItemTextBox = {}
}, i.updateLegend = function(a, b, c) {
    function d(a, b) {
        return y.legendItemTextBox[b] || (y.legendItemTextBox[b] = y.getTextRect(a.textContent, l.legendItem, a)), y.legendItemTextBox[b]
    }
    function e(b, c, e) {
        function f(a, b) {
            b || (g = (o - G - n) / 2, E &gt; g &amp;&amp; (g = (o - n) / 2, G = 0, M++)), L[a] = M, K[M] = y.isLegendInset ? 10 : g, H[a] = G, G += n
        }
        var g,
        h,
        i = 0 === e,
        j = e === a.length - 1,
        k = d(b, c),
        l = k.width + F + (!j || y.isLegendRight || y.isLegendInset ? B : 0) + z.legend_padding,
        m = k.height + A,
        n = y.isLegendRight || y.isLegendInset ? m : l,
        o = y.isLegendRight || y.isLegendInset ? y.getLegendHeight() : y.getLegendWidth();
        return i &amp;&amp; (G = 0, M = 0, C = 0, D = 0), z.legend_show &amp;&amp; !y.isLegendToShow(c) ? void (I[c] = J[c] = L[c] = H[c] = 0) : (I[c] = l, J[c] = m, (!C || l &gt;= C) &amp;&amp; (C = l), (!D || m &gt;= D) &amp;&amp; (D = m), h = y.isLegendRight || y.isLegendInset ? D : C, void (z.legend_equally ? (Object.keys(I).forEach(function(a) {
            I[a] = C
        }), Object.keys(J).forEach(function(a) {
            J[a] = D
        }), g = (o - h * a.length) / 2, E &gt; g ? (G = 0, M = 0, a.forEach(function(a) {
            f(a)
        })) : f(c, !0)) : f(c)))
    }
    var f,
    g,
    h,
    i,
    j,
    k,
    m,
    n,
    o,
    p,
    r,
    s,
    t,
    u,
    v,
    x,
    y = this,
    z = y.config,
    A = 4,
    B = 10,
    C = 0,
    D = 0,
    E = 10,
    F = z.legend_item_tile_width + 5,
    G = 0,
    H = {},
    I = {},
    J = {},
    K = [0],
    L = {},
    M = 0;
    a = a.filter(function(a) {
        return !q(z.data_names[a]) || null !== z.data_names[a]
    }), b = b || {}, r = w(b, &quot;withTransition&quot;, !0), s = w(b, &quot;withTransitionForTransform&quot;, !0), y.isLegendInset &amp;&amp; (M = z.legend_inset_step ? z.legend_inset_step : a.length, y.updateLegendStep(M)), y.isLegendRight ? (f = function(a) {
        return C * L[a]
    }, i = function(a) {
        return K[L[a]] + H[a]
    }) : y.isLegendInset ? (f = function(a) {
        return C * L[a] + 10
    }, i = function(a) {
        return K[L[a]] + H[a]
    }) : (f = function(a) {
        return K[L[a]] + H[a]
    }, i = function(a) {
        return D * L[a]
    }), g = function(a, b) {
        return f(a, b) + 4 + z.legend_item_tile_width
    }, j = function(a, b) {
        return i(a, b) + 9
    }, h = function(a, b) {
        return f(a, b)
    }, k = function(a, b) {
        return i(a, b) - 5
    }, m = function(a, b) {
        return f(a, b) - 2
    }, n = function(a, b) {
        return f(a, b) - 2 + z.legend_item_tile_width
    }, o = function(a, b) {
        return i(a, b) + 4
    }, p = y.legend.selectAll(&quot;.&quot; + l.legendItem).data(a).enter().append(&quot;g&quot;).attr(&quot;class&quot;, function(a) {
        return y.generateClass(l.legendItem, a)
    }).style(&quot;visibility&quot;, function(a) {
        return y.isLegendToShow(a) ? &quot;visible&quot; : &quot;hidden&quot;
    }).style(&quot;cursor&quot;, &quot;pointer&quot;).on(&quot;click&quot;, function(a) {
        z.legend_item_onclick ? z.legend_item_onclick.call(y, a) : y.d3.event.altKey ? (y.api.hide(), y.api.show(a)) : (y.api.toggle(a), y.isTargetToShow(a) ? y.api.focus(a) : y.api.revert())
    }).on(&quot;mouseover&quot;, function(a) {
        z.legend_item_onmouseover ? z.legend_item_onmouseover.call(y, a) : (y.d3.select(this).classed(l.legendItemFocused, !0), !y.transiting &amp;&amp; y.isTargetToShow(a) &amp;&amp; y.api.focus(a))
    }).on(&quot;mouseout&quot;, function(a) {
        z.legend_item_onmouseout ? z.legend_item_onmouseout.call(y, a) : (y.d3.select(this).classed(l.legendItemFocused, !1), y.api.revert())
    }), p.append(&quot;text&quot;).text(function(a) {
        return q(z.data_names[a]) ? z.data_names[a] : a
    }).each(function(a, b) {
        e(this, a, b)
    }).style(&quot;pointer-events&quot;, &quot;none&quot;).attr(&quot;x&quot;, y.isLegendRight || y.isLegendInset ? g : -200).attr(&quot;y&quot;, y.isLegendRight || y.isLegendInset ? -200 : j), p.append(&quot;rect&quot;).attr(&quot;class&quot;, l.legendItemEvent).style(&quot;fill-opacity&quot;, 0).attr(&quot;x&quot;, y.isLegendRight || y.isLegendInset ? h : -200).attr(&quot;y&quot;, y.isLegendRight || y.isLegendInset ? -200 : k), p.append(&quot;line&quot;).attr(&quot;class&quot;, l.legendItemTile).style(&quot;stroke&quot;, y.color).style(&quot;pointer-events&quot;, &quot;none&quot;).attr(&quot;x1&quot;, y.isLegendRight || y.isLegendInset ? m : -200).attr(&quot;y1&quot;, y.isLegendRight || y.isLegendInset ? -200 : o).attr(&quot;x2&quot;, y.isLegendRight || y.isLegendInset ? n : -200).attr(&quot;y2&quot;, y.isLegendRight || y.isLegendInset ? -200 : o).attr(&quot;stroke-width&quot;, z.legend_item_tile_height), x = y.legend.select(&quot;.&quot; + l.legendBackground + &quot; rect&quot;), y.isLegendInset &amp;&amp; C &gt; 0 &amp;&amp; 0 === x.size() &amp;&amp; (x = y.legend.insert(&quot;g&quot;, &quot;.&quot; + l.legendItem).attr(&quot;class&quot;, l.legendBackground).append(&quot;rect&quot;)), t = y.legend.selectAll(&quot;text&quot;).data(a).text(function(a) {
        return q(z.data_names[a]) ? z.data_names[a] : a
    }).each(function(a, b) {
        e(this, a, b)
    }), (r ? t.transition() : t).attr(&quot;x&quot;, g).attr(&quot;y&quot;, j), u = y.legend.selectAll(&quot;rect.&quot; + l.legendItemEvent).data(a), (r ? u.transition() : u).attr(&quot;width&quot;, function(a) {
        return I[a]
    }).attr(&quot;height&quot;, function(a) {
        return J[a]
    }).attr(&quot;x&quot;, h).attr(&quot;y&quot;, k), v = y.legend.selectAll(&quot;line.&quot; + l.legendItemTile).data(a), (r ? v.transition() : v).style(&quot;stroke&quot;, y.color).attr(&quot;x1&quot;, m).attr(&quot;y1&quot;, o).attr(&quot;x2&quot;, n).attr(&quot;y2&quot;, o), x &amp;&amp; (r ? x.transition() : x).attr(&quot;height&quot;, y.getLegendHeight() - 12).attr(&quot;width&quot;, C * (M + 1) + 10), y.legend.selectAll(&quot;.&quot; + l.legendItem).classed(l.legendItemHidden, function(a) {
        return !y.isTargetToShow(a)
    }), y.updateLegendItemWidth(C), y.updateLegendItemHeight(D), y.updateLegendStep(M), y.updateSizes(), y.updateScales(), y.updateSvgSize(), y.transformAll(s, c), y.legendHasRendered = !0
}, i.initTitle = function() {
    var a = this;
    a.title = a.svg.append(&quot;text&quot;).text(a.config.title_text).attr(&quot;class&quot;, a.CLASS.title)
}, i.redrawTitle = function() {
    var a = this;
    a.title.attr(&quot;x&quot;, a.xForTitle.bind(a)).attr(&quot;y&quot;, a.yForTitle.bind(a))
}, i.xForTitle = function() {
    var a,
    b = this,
    c = b.config,
    d = c.title_position || &quot;left&quot;;
    return a = d.indexOf(&quot;right&quot;) &gt;= 0 ? b.currentWidth - b.getTextRect(b.title.node().textContent, b.CLASS.title, b.title.node()).width - c.title_padding.right : d.indexOf(&quot;center&quot;) &gt;= 0 ? (b.currentWidth - b.getTextRect(b.title.node().textContent, b.CLASS.title, b.title.node()).width) / 2 : c.title_padding.left
}, i.yForTitle = function() {
    var a = this;
    return a.config.title_padding.top + a.getTextRect(a.title.node().textContent, a.CLASS.title, a.title.node()).height
}, i.getTitlePadding = function() {
    var a = this;
    return a.yForTitle() + a.config.title_padding.bottom
}, c(b, f), f.prototype.init = function() {
    var a = this.owner,
    b = a.config,
    c = a.main;
    a.axes.x = c.append(&quot;g&quot;).attr(&quot;class&quot;, l.axis + &quot; &quot; + l.axisX).attr(&quot;clip-path&quot;, a.clipPathForXAxis).attr(&quot;transform&quot;, a.getTranslate(&quot;x&quot;)).style(&quot;visibility&quot;, b.axis_x_show ? &quot;visible&quot; : &quot;hidden&quot;), a.axes.x.append(&quot;text&quot;).attr(&quot;class&quot;, l.axisXLabel).attr(&quot;transform&quot;, b.axis_rotated ? &quot;rotate(-90)&quot; : &quot;&quot;).style(&quot;text-anchor&quot;, this.textAnchorForXAxisLabel.bind(this)), a.axes.y = c.append(&quot;g&quot;).attr(&quot;class&quot;, l.axis + &quot; &quot; + l.axisY).attr(&quot;clip-path&quot;, b.axis_y_inner ? &quot;&quot; : a.clipPathForYAxis).attr(&quot;transform&quot;, a.getTranslate(&quot;y&quot;)).style(&quot;visibility&quot;, b.axis_y_show ? &quot;visible&quot; : &quot;hidden&quot;), a.axes.y.append(&quot;text&quot;).attr(&quot;class&quot;, l.axisYLabel).attr(&quot;transform&quot;, b.axis_rotated ? &quot;&quot; : &quot;rotate(-90)&quot;).style(&quot;text-anchor&quot;, this.textAnchorForYAxisLabel.bind(this)), a.axes.y2 = c.append(&quot;g&quot;).attr(&quot;class&quot;, l.axis + &quot; &quot; + l.axisY2).attr(&quot;transform&quot;, a.getTranslate(&quot;y2&quot;)).style(&quot;visibility&quot;, b.axis_y2_show ? &quot;visible&quot; : &quot;hidden&quot;), a.axes.y2.append(&quot;text&quot;).attr(&quot;class&quot;, l.axisY2Label).attr(&quot;transform&quot;, b.axis_rotated ? &quot;&quot; : &quot;rotate(-90)&quot;).style(&quot;text-anchor&quot;, this.textAnchorForY2AxisLabel.bind(this))
}, f.prototype.getXAxis = function(a, b, c, d, e, f, h) {
    var i = this.owner,
    j = i.config,
    k = {
        isCategory: i.isCategorized(),
        withOuterTick: e,
        tickMultiline: j.axis_x_tick_multiline,
        tickWidth: j.axis_x_tick_width,
        tickTextRotate: h ? 0 : j.axis_x_tick_rotate,
        withoutTransition: f
    },
    l = g(i.d3, k).scale(a).orient(b);
    return i.isTimeSeries() &amp;&amp; d &amp;&amp; &quot;function&quot; != typeof d &amp;&amp; (d = d.map(function(a) {
        return i.parseDate(a)
    })), l.tickFormat(c).tickValues(d), i.isCategorized() &amp;&amp; (l.tickCentered(j.axis_x_tick_centered), u(j.axis_x_tick_culling) &amp;&amp; (j.axis_x_tick_culling = !1)), l
}, f.prototype.updateXAxisTickValues = function(a, b) {
    var c,
    d = this.owner,
    e = d.config;
    return (e.axis_x_tick_fit || e.axis_x_tick_count) &amp;&amp; (c = this.generateTickValues(d.mapTargetsToUniqueXs(a), e.axis_x_tick_count, d.isTimeSeries())), b ? b.tickValues(c) : (d.xAxis.tickValues(c), d.subXAxis.tickValues(c)), c
}, f.prototype.getYAxis = function(a, b, c, d, e, f, h) {
    var i = this.owner,
    j = i.config,
    k = {
        withOuterTick: e,
        withoutTransition: f,
        tickTextRotate: h ? 0 : j.axis_y_tick_rotate
    },
    l = g(i.d3, k).scale(a).orient(b).tickFormat(c);
    return i.isTimeSeriesY() ? l.ticks(i.d3.time[j.axis_y_tick_time_value], j.axis_y_tick_time_interval) : l.tickValues(d), l
}, f.prototype.getId = function(a) {
    var b = this.owner.config;
    return a in b.data_axes ? b.data_axes[a] : &quot;y&quot;
}, f.prototype.getXAxisTickFormat = function() {
    var a = this.owner,
    b = a.config,
    c = a.isTimeSeries() ? a.defaultAxisTimeFormat : a.isCategorized() ? a.categoryName : function(a) {
        return 0 &gt; a ? a.toFixed(0) : a
    };
    return b.axis_x_tick_format &amp;&amp; (n(b.axis_x_tick_format) ? c = b.axis_x_tick_format : a.isTimeSeries() &amp;&amp; (c = function(c) {
        return c ? a.axisTimeFormat(b.axis_x_tick_format)(c) : &quot;&quot;
    })), n(c) ? function(b) {
        return c.call(a, b)
    } : c
}, f.prototype.getTickValues = function(a, b) {
    return a ? a : b ? b.tickValues() : void 0
}, f.prototype.getXAxisTickValues = function() {
    return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis)
}, f.prototype.getYAxisTickValues = function() {
    return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis)
}, f.prototype.getY2AxisTickValues = function() {
    return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis)
}, f.prototype.getLabelOptionByAxisId = function(a) {
    var b,
    c = this.owner,
    d = c.config;
    return &quot;y&quot; === a ? b = d.axis_y_label : &quot;y2&quot; === a ? b = d.axis_y2_label : &quot;x&quot; === a &amp;&amp; (b = d.axis_x_label), b
}, f.prototype.getLabelText = function(a) {
    var b = this.getLabelOptionByAxisId(a);
    return o(b) ? b : b ? b.text : null
}, f.prototype.setLabelText = function(a, b) {
    var c = this.owner,
    d = c.config,
    e = this.getLabelOptionByAxisId(a);
    o(e) ? &quot;y&quot; === a ? d.axis_y_label = b : &quot;y2&quot; === a ? d.axis_y2_label = b : &quot;x&quot; === a &amp;&amp; (d.axis_x_label = b) : e &amp;&amp; (e.text = b)
}, f.prototype.getLabelPosition = function(a, b) {
    var c = this.getLabelOptionByAxisId(a),
    d = c &amp;&amp; &quot;object&quot; == typeof c &amp;&amp; c.position ? c.position : b;
    return {
        isInner: d.indexOf(&quot;inner&quot;) &gt;= 0,
        isOuter: d.indexOf(&quot;outer&quot;) &gt;= 0,
        isLeft: d.indexOf(&quot;left&quot;) &gt;= 0,
        isCenter: d.indexOf(&quot;center&quot;) &gt;= 0,
        isRight: d.indexOf(&quot;right&quot;) &gt;= 0,
        isTop: d.indexOf(&quot;top&quot;) &gt;= 0,
        isMiddle: d.indexOf(&quot;middle&quot;) &gt;= 0,
        isBottom: d.indexOf(&quot;bottom&quot;) &gt;= 0
    }
}, f.prototype.getXAxisLabelPosition = function() {
    return this.getLabelPosition(&quot;x&quot;, this.owner.config.axis_rotated ? &quot;inner-top&quot; : &quot;inner-right&quot;)
}, f.prototype.getYAxisLabelPosition = function() {
    return this.getLabelPosition(&quot;y&quot;, this.owner.config.axis_rotated ? &quot;inner-right&quot; : &quot;inner-top&quot;)
}, f.prototype.getY2AxisLabelPosition = function() {
    return this.getLabelPosition(&quot;y2&quot;, this.owner.config.axis_rotated ? &quot;inner-right&quot; : &quot;inner-top&quot;)
}, f.prototype.getLabelPositionById = function(a) {
    return &quot;y2&quot; === a ? this.getY2AxisLabelPosition() : &quot;y&quot; === a ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition()
}, f.prototype.textForXAxisLabel = function() {
    return this.getLabelText(&quot;x&quot;)
}, f.prototype.textForYAxisLabel = function() {
    return this.getLabelText(&quot;y&quot;)
}, f.prototype.textForY2AxisLabel = function() {
    return this.getLabelText(&quot;y2&quot;)
}, f.prototype.xForAxisLabel = function(a, b) {
    var c = this.owner;
    return a ? b.isLeft ? 0 : b.isCenter ? c.width / 2 : c.width : b.isBottom ? -c.height : b.isMiddle ? -c.height / 2 : 0
}, f.prototype.dxForAxisLabel = function(a, b) {
    return a ? b.isLeft ? &quot;0.5em&quot; : b.isRight ? &quot;-0.5em&quot; : &quot;0&quot; : b.isTop ? &quot;-0.5em&quot; : b.isBottom ? &quot;0.5em&quot; : &quot;0&quot;
}, f.prototype.textAnchorForAxisLabel = function(a, b) {
    return a ? b.isLeft ? &quot;start&quot; : b.isCenter ? &quot;middle&quot; : &quot;end&quot; : b.isBottom ? &quot;start&quot; : b.isMiddle ? &quot;middle&quot; : &quot;end&quot;
}, f.prototype.xForXAxisLabel = function() {
    return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition())
}, f.prototype.xForYAxisLabel = function() {
    return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition())
}, f.prototype.xForY2AxisLabel = function() {
    return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition())
}, f.prototype.dxForXAxisLabel = function() {
    return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition())
}, f.prototype.dxForYAxisLabel = function() {
    return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition())
}, f.prototype.dxForY2AxisLabel = function() {
    return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition())
}, f.prototype.dyForXAxisLabel = function() {
    var a = this.owner,
    b = a.config,
    c = this.getXAxisLabelPosition();
    return b.axis_rotated ? c.isInner ? &quot;1.2em&quot; : -25 - this.getMaxTickWidth(&quot;x&quot;) : c.isInner ? &quot;-0.5em&quot; : b.axis_x_height ? b.axis_x_height - 10 : &quot;3em&quot;
}, f.prototype.dyForYAxisLabel = function() {
    var a = this.owner,
    b = this.getYAxisLabelPosition();
    return a.config.axis_rotated ? b.isInner ? &quot;-0.5em&quot; : &quot;3em&quot; : b.isInner ? &quot;1.2em&quot; : -10 - (a.config.axis_y_inner ? 0 : this.getMaxTickWidth(&quot;y&quot;) + 10)
}, f.prototype.dyForY2AxisLabel = function() {
    var a = this.owner,
    b = this.getY2AxisLabelPosition();
    return a.config.axis_rotated ? b.isInner ? &quot;1.2em&quot; : &quot;-2.2em&quot; : b.isInner ? &quot;-0.5em&quot; : 15 + (a.config.axis_y2_inner ? 0 : this.getMaxTickWidth(&quot;y2&quot;) + 15)
}, f.prototype.textAnchorForXAxisLabel = function() {
    var a = this.owner;
    return this.textAnchorForAxisLabel(!a.config.axis_rotated, this.getXAxisLabelPosition())
}, f.prototype.textAnchorForYAxisLabel = function() {
    var a = this.owner;
    return this.textAnchorForAxisLabel(a.config.axis_rotated, this.getYAxisLabelPosition())
}, f.prototype.textAnchorForY2AxisLabel = function() {
    var a = this.owner;
    return this.textAnchorForAxisLabel(a.config.axis_rotated, this.getY2AxisLabelPosition())
}, f.prototype.getMaxTickWidth = function(a, b) {
    var c,
    d,
    e,
    f,
    g,
    h = this.owner,
    i = h.config,
    j = 0;
    return b &amp;&amp; h.currentMaxTickWidths[a] ? h.currentMaxTickWidths[a] : (h.svg &amp;&amp; (c = h.filterTargetsToShow(h.data.targets), &quot;y&quot; === a ? (d = h.y.copy().domain(h.getYDomain(c, &quot;y&quot;)), e = this.getYAxis(d, h.yOrient, i.axis_y_tick_format, h.yAxisTickValues, !1, !0, !0)) : &quot;y2&quot; === a ? (d = h.y2.copy().domain(h.getYDomain(c, &quot;y2&quot;)),
    e = this.getYAxis(d, h.y2Orient, i.axis_y2_tick_format, h.y2AxisTickValues, !1, !0, !0)) : (d = h.x.copy().domain(h.getXDomain(c)), e = this.getXAxis(d, h.xOrient, h.xAxisTickFormat, h.xAxisTickValues, !1, !0, !0), this.updateXAxisTickValues(c, e)), f = h.d3.select(&quot;body&quot;).append(&quot;div&quot;).classed(&quot;c3&quot;, !0), g = f.append(&quot;svg&quot;).style(&quot;visibility&quot;, &quot;hidden&quot;).style(&quot;position&quot;, &quot;fixed&quot;).style(&quot;top&quot;, 0).style(&quot;left&quot;, 0), g.append(&quot;g&quot;).call(e).each(function() {
        h.d3.select(this).selectAll(&quot;text&quot;).each(function() {
            var a = this.getBoundingClientRect();
            j &lt; a.width &amp;&amp; (j = a.width)
        }), f.remove()
    })), h.currentMaxTickWidths[a] = 0 &gt;= j ? h.currentMaxTickWidths[a] : j, h.currentMaxTickWidths[a])
}, f.prototype.updateLabels = function(a) {
    var b = this.owner,
    c = b.main.select(&quot;.&quot; + l.axisX + &quot; .&quot; + l.axisXLabel),
    d = b.main.select(&quot;.&quot; + l.axisY + &quot; .&quot; + l.axisYLabel),
    e = b.main.select(&quot;.&quot; + l.axisY2 + &quot; .&quot; + l.axisY2Label);
    (a ? c.transition() : c).attr(&quot;x&quot;, this.xForXAxisLabel.bind(this)).attr(&quot;dx&quot;, this.dxForXAxisLabel.bind(this)).attr(&quot;dy&quot;, this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this)), (a ? d.transition() : d).attr(&quot;x&quot;, this.xForYAxisLabel.bind(this)).attr(&quot;dx&quot;, this.dxForYAxisLabel.bind(this)).attr(&quot;dy&quot;, this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this)), (a ? e.transition() : e).attr(&quot;x&quot;, this.xForY2AxisLabel.bind(this)).attr(&quot;dx&quot;, this.dxForY2AxisLabel.bind(this)).attr(&quot;dy&quot;, this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this))
}, f.prototype.getPadding = function(a, b, c, d) {
    var e = &quot;number&quot; == typeof a ? a : a[b];
    return m(e) ? &quot;ratio&quot; === a.unit ? a[b] * d : this.convertPixelsToAxisPadding(e, d) : c
}, f.prototype.convertPixelsToAxisPadding = function(a, b) {
    var c = this.owner,
    d = c.config.axis_rotated ? c.width : c.height;
    return b * (a / d)
}, f.prototype.generateTickValues = function(a, b, c) {
    var d,
    e,
    f,
    g,
    h,
    i,
    j,
    k = a;
    if (b)
    if (d = n(b) ? b() : b, 1 === d)
    k = [a[0]];
    else if (2 === d)
    k = [a[0], a[a.length - 1]];
    else if (d &gt; 2) {
        for (g = d - 2, e = a[0], f = a[a.length - 1], h = (f - e) / (g + 1), k = [e], i = 0; g &gt; i; i++)
        j = +e + h * (i + 1), k.push(c ? new Date(j) : j);
        k.push(f)
    }
    return c || (k = k.sort(function(a, b) {
        return a - b
    })), k
}, f.prototype.generateTransitions = function(a) {
    var b = this.owner,
    c = b.axes;
    return {
        axisX: a ? c.x.transition().duration(a) : c.x,
        axisY: a ? c.y.transition().duration(a) : c.y,
        axisY2: a ? c.y2.transition().duration(a) : c.y2,
        axisSubX: a ? c.subx.transition().duration(a) : c.subx
    }
}, f.prototype.redraw = function(a, b) {
    var c = this.owner;
    c.axes.x.style(&quot;opacity&quot;, b ? 0 : 1), c.axes.y.style(&quot;opacity&quot;, b ? 0 : 1), c.axes.y2.style(&quot;opacity&quot;, b ? 0 : 1), c.axes.subx.style(&quot;opacity&quot;, b ? 0 : 1), a.axisX.call(c.xAxis), a.axisY.call(c.yAxis), a.axisY2.call(c.y2Axis), a.axisSubX.call(c.subXAxis)
}, i.getClipPath = function(b) {
    var c = a.navigator.appVersion.toLowerCase().indexOf(&quot;msie 9.&quot;) &gt;= 0;
    return &quot;url(&quot; + (c ? &quot;&quot; : document.URL.split(&quot;#&quot;)[0]) + &quot;#&quot; + b + &quot;)&quot;
}, i.appendClip = function(a, b) {
    return a.append(&quot;clipPath&quot;).attr(&quot;id&quot;, b).append(&quot;rect&quot;)
}, i.getAxisClipX = function(a) {
    var b = Math.max(30, this.margin.left);
    return a ? -(1 + b) : -(b - 1)
}, i.getAxisClipY = function(a) {
    return a ? -20 : -this.margin.top
}, i.getXAxisClipX = function() {
    var a = this;
    return a.getAxisClipX(!a.config.axis_rotated)
}, i.getXAxisClipY = function() {
    var a = this;
    return a.getAxisClipY(!a.config.axis_rotated)
}, i.getYAxisClipX = function() {
    var a = this;
    return a.config.axis_y_inner ? -1 : a.getAxisClipX(a.config.axis_rotated)
}, i.getYAxisClipY = function() {
    var a = this;
    return a.getAxisClipY(a.config.axis_rotated)
}, i.getAxisClipWidth = function(a) {
    var b = this,
    c = Math.max(30, b.margin.left),
    d = Math.max(30, b.margin.right);
    return a ? b.width + 2 + c + d : b.margin.left + 20
}, i.getAxisClipHeight = function(a) {
    return (a ? this.margin.bottom : this.margin.top + this.height) + 20
}, i.getXAxisClipWidth = function() {
    var a = this;
    return a.getAxisClipWidth(!a.config.axis_rotated)
}, i.getXAxisClipHeight = function() {
    var a = this;
    return a.getAxisClipHeight(!a.config.axis_rotated)
}, i.getYAxisClipWidth = function() {
    var a = this;
    return a.getAxisClipWidth(a.config.axis_rotated) + (a.config.axis_y_inner ? 20 : 0)
}, i.getYAxisClipHeight = function() {
    var a = this;
    return a.getAxisClipHeight(a.config.axis_rotated)
}, i.initPie = function() {
    var a = this,
    b = a.d3,
    c = a.config;
    a.pie = b.layout.pie().value(function(a) {
        return a.values.reduce(function(a, b) {
            return a + b.value
        }, 0)
    }), c.data_order || a.pie.sort(null)
}, i.updateRadius = function() {
    var a = this,
    b = a.config,
    c = b.gauge_width || b.donut_width;
    a.radiusExpanded = Math.min(a.arcWidth, a.arcHeight) / 2, a.radius = .95 * a.radiusExpanded, a.innerRadiusRatio = c ? (a.radius - c) / a.radius : .6, a.innerRadius = a.hasType(&quot;donut&quot;) || a.hasType(&quot;gauge&quot;) ? a.radius * a.innerRadiusRatio : 0
}, i.updateArc = function() {
    var a = this;
    a.svgArc = a.getSvgArc(), a.svgArcExpanded = a.getSvgArcExpanded(), a.svgArcExpandedSub = a.getSvgArcExpanded(.98)
}, i.updateAngle = function(a) {
    var b,
    c,
    d,
    e,
    f = this,
    g = f.config,
    h = !1,
    i = 0;
    return g ? (f.pie(f.filterTargetsToShow(f.data.targets)).forEach(function(b) {
        h || b.data.id !== a.data.id || (h = !0, a = b, a.index = i), i++
    }), isNaN(a.startAngle) &amp;&amp; (a.startAngle = 0), isNaN(a.endAngle) &amp;&amp; (a.endAngle = a.startAngle), f.isGaugeType(a.data) &amp;&amp; (b = g.gauge_min, c = g.gauge_max, d = Math.PI * (g.gauge_fullCircle ? 2 : 1) / (c - b), e = a.value &lt; b ? 0 : a.value &lt; c ? a.value - b : c - b, a.startAngle = g.gauge_startingAngle, a.endAngle = a.startAngle + d * e), h ? a : null) : null
}, i.getSvgArc = function() {
    var a = this,
    b = a.d3.svg.arc().outerRadius(a.radius).innerRadius(a.innerRadius),
    c = function(c, d) {
        var e;
        return d ? b(c) : (e = a.updateAngle(c), e ? b(e) : &quot;M 0 0&quot;)
    };
    return c.centroid = b.centroid, c
}, i.getSvgArcExpanded = function(a) {
    var b = this,
    c = b.d3.svg.arc().outerRadius(b.radiusExpanded * (a ? a : 1)).innerRadius(b.innerRadius);
    return function(a) {
        var d = b.updateAngle(a);
        return d ? c(d) : &quot;M 0 0&quot;
    }
}, i.getArc = function(a, b, c) {
    return c || this.isArcType(a.data) ? this.svgArc(a, b) : &quot;M 0 0&quot;
}, i.transformForArcLabel = function(a) {
    var b,
    c,
    d,
    e,
    f,
    g = this,
    h = g.config,
    i = g.updateAngle(a),
    j = &quot;&quot;;
    return i &amp;&amp; !g.hasType(&quot;gauge&quot;) &amp;&amp; (b = this.svgArc.centroid(i), c = isNaN(b[0]) ? 0 : b[0], d = isNaN(b[1]) ? 0 : b[1], e = Math.sqrt(c * c + d * d), f = g.hasType(&quot;donut&quot;) &amp;&amp; h.donut_label_ratio ? n(h.donut_label_ratio) ? h.donut_label_ratio(a, g.radius, e) : h.donut_label_ratio : g.hasType(&quot;pie&quot;) &amp;&amp; h.pie_label_ratio ? n(h.pie_label_ratio) ? h.pie_label_ratio(a, g.radius, e) : h.pie_label_ratio : g.radius &amp;&amp; e ? (36 / g.radius &gt; .375 ? 1.175 - 36 / g.radius : .8) * g.radius / e : 0, j = &quot;translate(&quot; + c * f + &quot;,&quot; + d * f + &quot;)&quot;), j
}, i.getArcRatio = function(a) {
    var b = this,
    c = b.config,
    d = Math.PI * (b.hasType(&quot;gauge&quot;) &amp;&amp; !c.gauge_fullCircle ? 1 : 2);
    return a ? (a.endAngle - a.startAngle) / d : null
}, i.convertToArcData = function(a) {
    return this.addName({
        id: a.data.id,
        value: a.value,
        ratio: this.getArcRatio(a),
        index: a.index
    })
}, i.textForArcLabel = function(a) {
    var b,
    c,
    d,
    e,
    f,
    g = this;
    return g.shouldShowArcLabel() ? (b = g.updateAngle(a), c = b ? b.value : null, d = g.getArcRatio(b), e = a.data.id, g.hasType(&quot;gauge&quot;) || g.meetsArcLabelThreshold(d) ? (f = g.getArcLabelFormat(), f ? f(c, d, e) : g.defaultArcValueFormat(c, d)) : &quot;&quot;) : &quot;&quot;
}, i.expandArc = function(b) {
    var c,
    d = this;
    return d.transiting ? void (c = a.setInterval(function() {
        d.transiting || (a.clearInterval(c), d.legend.selectAll(&quot;.c3-legend-item-focused&quot;).size() &gt; 0 &amp;&amp; d.expandArc(b))
    }, 10)) : (b = d.mapToTargetIds(b), void d.svg.selectAll(d.selectorTargets(b, &quot;.&quot; + l.chartArc)).each(function(a) {
        d.shouldExpand(a.data.id) &amp;&amp; d.d3.select(this).selectAll(&quot;path&quot;).transition().duration(d.expandDuration(a.data.id)).attr(&quot;d&quot;, d.svgArcExpanded).transition().duration(2 * d.expandDuration(a.data.id)).attr(&quot;d&quot;, d.svgArcExpandedSub).each(function(a) {
            d.isDonutType(a.data)
        })
    }))
}, i.unexpandArc = function(a) {
    var b = this;
    b.transiting || (a = b.mapToTargetIds(a), b.svg.selectAll(b.selectorTargets(a, &quot;.&quot; + l.chartArc)).selectAll(&quot;path&quot;).transition().duration(function(a) {
        return b.expandDuration(a.data.id)
    }).attr(&quot;d&quot;, b.svgArc), b.svg.selectAll(&quot;.&quot; + l.arc).style(&quot;opacity&quot;, 1))
}, i.expandDuration = function(a) {
    var b = this,
    c = b.config;
    return b.isDonutType(a) ? c.donut_expand_duration : b.isGaugeType(a) ? c.gauge_expand_duration : b.isPieType(a) ? c.pie_expand_duration : 50
}, i.shouldExpand = function(a) {
    var b = this,
    c = b.config;
    return b.isDonutType(a) &amp;&amp; c.donut_expand || b.isGaugeType(a) &amp;&amp; c.gauge_expand || b.isPieType(a) &amp;&amp; c.pie_expand
}, i.shouldShowArcLabel = function() {
    var a = this,
    b = a.config,
    c = !0;
    return a.hasType(&quot;donut&quot;) ? c = b.donut_label_show : a.hasType(&quot;pie&quot;) &amp;&amp; (c = b.pie_label_show), c
}, i.meetsArcLabelThreshold = function(a) {
    var b = this,
    c = b.config,
    d = b.hasType(&quot;donut&quot;) ? c.donut_label_threshold : c.pie_label_threshold;
    return a &gt;= d
}, i.getArcLabelFormat = function() {
    var a = this,
    b = a.config,
    c = b.pie_label_format;
    return a.hasType(&quot;gauge&quot;) ? c = b.gauge_label_format : a.hasType(&quot;donut&quot;) &amp;&amp; (c = b.donut_label_format), c
}, i.getArcTitle = function() {
    var a = this;
    return a.hasType(&quot;donut&quot;) ? a.config.donut_title : &quot;&quot;
}, i.updateTargetsForArc = function(a) {
    var b,
    c,
    d = this,
    e = d.main,
    f = d.classChartArc.bind(d),
    g = d.classArcs.bind(d),
    h = d.classFocus.bind(d);
    b = e.select(&quot;.&quot; + l.chartArcs).selectAll(&quot;.&quot; + l.chartArc).data(d.pie(a)).attr(&quot;class&quot;, function(a) {
        return f(a) + h(a.data)
    }), c = b.enter().append(&quot;g&quot;).attr(&quot;class&quot;, f), c.append(&quot;g&quot;).attr(&quot;class&quot;, g), c.append(&quot;text&quot;).attr(&quot;dy&quot;, d.hasType(&quot;gauge&quot;) ? &quot;-.1em&quot; : &quot;.35em&quot;).style(&quot;opacity&quot;, 0).style(&quot;text-anchor&quot;, &quot;middle&quot;).style(&quot;pointer-events&quot;, &quot;none&quot;)
}, i.initArc = function() {
    var a = this;
    a.arcs = a.main.select(&quot;.&quot; + l.chart).append(&quot;g&quot;).attr(&quot;class&quot;, l.chartArcs).attr(&quot;transform&quot;, a.getTranslate(&quot;arc&quot;)), a.arcs.append(&quot;text&quot;).attr(&quot;class&quot;, l.chartArcsTitle).style(&quot;text-anchor&quot;, &quot;middle&quot;).text(a.getArcTitle())
}, i.redrawArc = function(a, b, c) {
    var d,
    e = this,
    f = e.d3,
    g = e.config,
    h = e.main;
    d = h.selectAll(&quot;.&quot; + l.arcs).selectAll(&quot;.&quot; + l.arc).data(e.arcData.bind(e)), d.enter().append(&quot;path&quot;).attr(&quot;class&quot;, e.classArc.bind(e)).style(&quot;fill&quot;, function(a) {
        return e.color(a.data)
    }).style(&quot;cursor&quot;, function(a) {
        return g.interaction_enabled &amp;&amp; g.data_selection_isselectable(a) ? &quot;pointer&quot; : null
    }).style(&quot;opacity&quot;, 0).each(function(a) {
        e.isGaugeType(a.data) &amp;&amp; (a.startAngle = a.endAngle = g.gauge_startingAngle), this._current = a
    }), d.attr(&quot;transform&quot;, function(a) {
        return !e.isGaugeType(a.data) &amp;&amp; c ? &quot;scale(0)&quot; : &quot;&quot;
    }).style(&quot;opacity&quot;, function(a) {
        return a === this._current ? 0 : 1
    }).on(&quot;mouseover&quot;, g.interaction_enabled ? function(a) {
        var b,
        c;
        e.transiting || (b = e.updateAngle(a), b &amp;&amp; (c = e.convertToArcData(b), e.expandArc(b.data.id), e.api.focus(b.data.id), e.toggleFocusLegend(b.data.id, !0), e.config.data_onmouseover(c, this)))
    } : null).on(&quot;mousemove&quot;, g.interaction_enabled ? function(a) {
        var b,
        c,
        d = e.updateAngle(a);
        d &amp;&amp; (b = e.convertToArcData(d), c = [b], e.showTooltip(c, this))
    } : null).on(&quot;mouseout&quot;, g.interaction_enabled ? function(a) {
        var b,
        c;
        e.transiting || (b = e.updateAngle(a), b &amp;&amp; (c = e.convertToArcData(b), e.unexpandArc(b.data.id), e.api.revert(), e.revertLegend(), e.hideTooltip(), e.config.data_onmouseout(c, this)))
    } : null).on(&quot;click&quot;, g.interaction_enabled ? function(a, b) {
        var c,
        d = e.updateAngle(a);
        d &amp;&amp; (c = e.convertToArcData(d), e.toggleShape &amp;&amp; e.toggleShape(this, c, b), e.config.data_onclick.call(e.api, c, this))
    } : null).each(function() {
        e.transiting = !0
    }).transition().duration(a).attrTween(&quot;d&quot;, function(a) {
        var b,
        c = e.updateAngle(a);
        return c ? (isNaN(this._current.startAngle) &amp;&amp; (this._current.startAngle = 0), isNaN(this._current.endAngle) &amp;&amp; (this._current.endAngle = this._current.startAngle), b = f.interpolate(this._current, c), this._current = b(0), function(c) {
            var d = b(c);
            return d.data = a.data, e.getArc(d, !0)
        }) : function() {
            return &quot;M 0 0&quot;
        }
    }).attr(&quot;transform&quot;, c ? &quot;scale(1)&quot; : &quot;&quot;).style(&quot;fill&quot;, function(a) {
        return e.levelColor ? e.levelColor(a.data.values[0].value) : e.color(a.data.id)
    }).style(&quot;opacity&quot;, 1).call(e.endall, function() {
        e.transiting = !1
    }), d.exit().transition().duration(b).style(&quot;opacity&quot;, 0).remove(), h.selectAll(&quot;.&quot; + l.chartArc).select(&quot;text&quot;).style(&quot;opacity&quot;, 0).attr(&quot;class&quot;, function(a) {
        return e.isGaugeType(a.data) ? l.gaugeValue : &quot;&quot;
    }).text(e.textForArcLabel.bind(e)).attr(&quot;transform&quot;, e.transformForArcLabel.bind(e)).style(&quot;font-size&quot;, function(a) {
        return e.isGaugeType(a.data) ? Math.round(e.radius / 5) + &quot;px&quot; : &quot;&quot;
    }).transition().duration(a).style(&quot;opacity&quot;, function(a) {
        return e.isTargetToShow(a.data.id) &amp;&amp; e.isArcType(a.data) ? 1 : 0
    }), h.select(&quot;.&quot; + l.chartArcsTitle).style(&quot;opacity&quot;, e.hasType(&quot;donut&quot;) || e.hasType(&quot;gauge&quot;) ? 1 : 0), e.hasType(&quot;gauge&quot;) &amp;&amp; (e.arcs.select(&quot;.&quot; + l.chartArcsBackground).attr(&quot;d&quot;, function() {
        var a = {
            data: [{
                value: g.gauge_max
            }],
            startAngle: g.gauge_startingAngle,
            endAngle: -1 * g.gauge_startingAngle
        };
        return e.getArc(a, !0, !0)
    }), e.arcs.select(&quot;.&quot; + l.chartArcsGaugeUnit).attr(&quot;dy&quot;, &quot;.75em&quot;).text(g.gauge_label_show ? g.gauge_units : &quot;&quot;), e.arcs.select(&quot;.&quot; + l.chartArcsGaugeMin).attr(&quot;dx&quot;, -1 * (e.innerRadius + (e.radius - e.innerRadius) / (g.gauge_fullCircle ? 1 : 2)) + &quot;px&quot;).attr(&quot;dy&quot;, &quot;1.2em&quot;).text(g.gauge_label_show ? g.gauge_min : &quot;&quot;), e.arcs.select(&quot;.&quot; + l.chartArcsGaugeMax).attr(&quot;dx&quot;, e.innerRadius + (e.radius - e.innerRadius) / (g.gauge_fullCircle ? 1 : 2) + &quot;px&quot;).attr(&quot;dy&quot;, &quot;1.2em&quot;).text(g.gauge_label_show ? g.gauge_max : &quot;&quot;))
}, i.initGauge = function() {
    var a = this.arcs;
    this.hasType(&quot;gauge&quot;) &amp;&amp; (a.append(&quot;path&quot;).attr(&quot;class&quot;, l.chartArcsBackground), a.append(&quot;text&quot;).attr(&quot;class&quot;, l.chartArcsGaugeUnit).style(&quot;text-anchor&quot;, &quot;middle&quot;).style(&quot;pointer-events&quot;, &quot;none&quot;), a.append(&quot;text&quot;).attr(&quot;class&quot;, l.chartArcsGaugeMin).style(&quot;text-anchor&quot;, &quot;middle&quot;).style(&quot;pointer-events&quot;, &quot;none&quot;), a.append(&quot;text&quot;).attr(&quot;class&quot;, l.chartArcsGaugeMax).style(&quot;text-anchor&quot;, &quot;middle&quot;).style(&quot;pointer-events&quot;, &quot;none&quot;))
}, i.getGaugeLabelHeight = function() {
    return this.config.gauge_label_show ? 20 : 0
}, i.initRegion = function() {
    var a = this;
    a.region = a.main.append(&quot;g&quot;).attr(&quot;clip-path&quot;, a.clipPath).attr(&quot;class&quot;, l.regions)
}, i.updateRegion = function(a) {
    var b = this,
    c = b.config;
    b.region.style(&quot;visibility&quot;, b.hasArcType() ? &quot;hidden&quot; : &quot;visible&quot;), b.mainRegion = b.main.select(&quot;.&quot; + l.regions).selectAll(&quot;.&quot; + l.region).data(c.regions), b.mainRegion.enter().append(&quot;g&quot;).append(&quot;rect&quot;).style(&quot;fill-opacity&quot;, 0), b.mainRegion.attr(&quot;class&quot;, b.classRegion.bind(b)), b.mainRegion.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove()
}, i.redrawRegion = function(a) {
    var b = this,
    c = b.mainRegion.selectAll(&quot;rect&quot;).each(function() {
        var a = b.d3.select(this.parentNode).datum();
        b.d3.select(this).datum(a)
    }),
    d = b.regionX.bind(b),
    e = b.regionY.bind(b),
    f = b.regionWidth.bind(b),
    g = b.regionHeight.bind(b);
    return [(a ? c.transition() : c).attr(&quot;x&quot;, d).attr(&quot;y&quot;, e).attr(&quot;width&quot;, f).attr(&quot;height&quot;, g).style(&quot;fill-opacity&quot;, function(a) {
        return m(a.opacity) ? a.opacity : .1
    })]
}, i.regionX = function(a) {
    var b,
    c = this,
    d = c.config,
    e = &quot;y&quot; === a.axis ? c.y : c.y2;
    return b = &quot;y&quot; === a.axis || &quot;y2&quot; === a.axis ? d.axis_rotated &amp;&amp; &quot;start&quot; in a ? e(a.start) : 0 : d.axis_rotated ? 0 : &quot;start&quot; in a ? c.x(c.isTimeSeries() ? c.parseDate(a.start) : a.start) : 0
}, i.regionY = function(a) {
    var b,
    c = this,
    d = c.config,
    e = &quot;y&quot; === a.axis ? c.y : c.y2;
    return b = &quot;y&quot; === a.axis || &quot;y2&quot; === a.axis ? d.axis_rotated ? 0 : &quot;end&quot; in a ? e(a.end) : 0 : d.axis_rotated &amp;&amp; &quot;start&quot; in a ? c.x(c.isTimeSeries() ? c.parseDate(a.start) : a.start) : 0
}, i.regionWidth = function(a) {
    var b,
    c = this,
    d = c.config,
    e = c.regionX(a),
    f = &quot;y&quot; === a.axis ? c.y : c.y2;
    return b = &quot;y&quot; === a.axis || &quot;y2&quot; === a.axis ? d.axis_rotated &amp;&amp; &quot;end&quot; in a ? f(a.end) : c.width : d.axis_rotated ? c.width : &quot;end&quot; in a ? c.x(c.isTimeSeries() ? c.parseDate(a.end) : a.end) : c.width, e &gt; b ? 0 : b - e
}, i.regionHeight = function(a) {
    var b,
    c = this,
    d = c.config,
    e = this.regionY(a),
    f = &quot;y&quot; === a.axis ? c.y : c.y2;
    return b = &quot;y&quot; === a.axis || &quot;y2&quot; === a.axis ? d.axis_rotated ? c.height : &quot;start&quot; in a ? f(a.start) : c.height : d.axis_rotated &amp;&amp; &quot;end&quot; in a ? c.x(c.isTimeSeries() ? c.parseDate(a.end) : a.end) : c.height, e &gt; b ? 0 : b - e
}, i.isRegionOnX = function(a) {
    return !a.axis || &quot;x&quot; === a.axis
}, i.drag = function(a) {
    var b,
    c,
    d,
    e,
    f,
    g,
    h,
    i,
    j = this,
    k = j.config,
    m = j.main,
    n = j.d3;
    j.hasArcType() || k.data_selection_enabled &amp;&amp; (k.zoom_enabled &amp;&amp; !j.zoom.altDomain || k.data_selection_multiple &amp;&amp; (b = j.dragStart[0], c = j.dragStart[1], d = a[0], e = a[1], f = Math.min(b, d), g = Math.max(b, d), h = k.data_selection_grouped ? j.margin.top : Math.min(c, e), i = k.data_selection_grouped ? j.height : Math.max(c, e), m.select(&quot;.&quot; + l.dragarea).attr(&quot;x&quot;, f).attr(&quot;y&quot;, h).attr(&quot;width&quot;, g - f).attr(&quot;height&quot;, i - h), m.selectAll(&quot;.&quot; + l.shapes).selectAll(&quot;.&quot; + l.shape).filter(function(a) {
        return k.data_selection_isselectable(a)
    }).each(function(a, b) {
        var c,
        d,
        e,
        k,
        m,
        o,
        p = n.select(this),
        q = p.classed(l.SELECTED),
        r = p.classed(l.INCLUDED),
        s = !1;
        if (p.classed(l.circle))
        c = 1 * p.attr(&quot;cx&quot;), d = 1 * p.attr(&quot;cy&quot;), m = j.togglePoint, s = c &gt; f &amp;&amp; g &gt; c &amp;&amp; d &gt; h &amp;&amp; i &gt; d;
        else {
            if (!p.classed(l.bar))
            return;
            o = z(this), c = o.x, d = o.y, e = o.width, k = o.height, m = j.togglePath, s = !(c &gt; g || f &gt; c + e || d &gt; i || h &gt; d + k)
        }
        s ^ r &amp;&amp; (p.classed(l.INCLUDED, !r), p.classed(l.SELECTED, !q), m.call(j, !q, p, a, b))
    })))
}, i.dragstart = function(a) {
    var b = this,
    c = b.config;
    b.hasArcType() || c.data_selection_enabled &amp;&amp; (b.dragStart = a, b.main.select(&quot;.&quot; + l.chart).append(&quot;rect&quot;).attr(&quot;class&quot;, l.dragarea).style(&quot;opacity&quot;, .1), b.dragging = !0)
}, i.dragend = function() {
    var a = this,
    b = a.config;
    a.hasArcType() || b.data_selection_enabled &amp;&amp; (a.main.select(&quot;.&quot; + l.dragarea).transition().duration(100).style(&quot;opacity&quot;, 0).remove(), a.main.selectAll(&quot;.&quot; + l.shape).classed(l.INCLUDED, !1), a.dragging = !1)
}, i.selectPoint = function(a, b, c) {
    var d = this,
    e = d.config,
    f = (e.axis_rotated ? d.circleY : d.circleX).bind(d),
    g = (e.axis_rotated ? d.circleX : d.circleY).bind(d),
    h = d.pointSelectR.bind(d);
    e.data_onselected.call(d.api, b, a.node()), d.main.select(&quot;.&quot; + l.selectedCircles + d.getTargetSelectorSuffix(b.id)).selectAll(&quot;.&quot; + l.selectedCircle + &quot;-&quot; + c).data([b]).enter().append(&quot;circle&quot;).attr(&quot;class&quot;, function() {
        return d.generateClass(l.selectedCircle, c)
    }).attr(&quot;cx&quot;, f).attr(&quot;cy&quot;, g).attr(&quot;stroke&quot;, function() {
        return d.color(b)
    }).attr(&quot;r&quot;, function(a) {
        return 1.4 * d.pointSelectR(a)
    }).transition().duration(100).attr(&quot;r&quot;, h)
}, i.unselectPoint = function(a, b, c) {
    var d = this;
    d.config.data_onunselected.call(d.api, b, a.node()), d.main.select(&quot;.&quot; + l.selectedCircles + d.getTargetSelectorSuffix(b.id)).selectAll(&quot;.&quot; + l.selectedCircle + &quot;-&quot; + c).transition().duration(100).attr(&quot;r&quot;, 0).remove()
}, i.togglePoint = function(a, b, c, d) {
    a ? this.selectPoint(b, c, d) : this.unselectPoint(b, c, d)
}, i.selectPath = function(a, b) {
    var c = this;
    c.config.data_onselected.call(c, b, a.node()), c.config.interaction_brighten &amp;&amp; a.transition().duration(100).style(&quot;fill&quot;, function() {
        return c.d3.rgb(c.color(b)).brighter(.75)
    })
}, i.unselectPath = function(a, b) {
    var c = this;
    c.config.data_onunselected.call(c, b, a.node()), c.config.interaction_brighten &amp;&amp; a.transition().duration(100).style(&quot;fill&quot;, function() {
        return c.color(b)
    })
}, i.togglePath = function(a, b, c, d) {
    a ? this.selectPath(b, c, d) : this.unselectPath(b, c, d)
}, i.getToggle = function(a, b) {
    var c,
    d = this;
    return &quot;circle&quot; === a.nodeName ? c = d.isStepType(b) ? function() {} : d.togglePoint : &quot;path&quot; === a.nodeName &amp;&amp; (c = d.togglePath), c
}, i.toggleShape = function(a, b, c) {
    var d = this,
    e = d.d3,
    f = d.config,
    g = e.select(a),
    h = g.classed(l.SELECTED),
    i = d.getToggle(a, b).bind(d);
    f.data_selection_enabled &amp;&amp; f.data_selection_isselectable(b) &amp;&amp; (f.data_selection_multiple || d.main.selectAll(&quot;.&quot; + l.shapes + (f.data_selection_grouped ? d.getTargetSelectorSuffix(b.id) : &quot;&quot;)).selectAll(&quot;.&quot; + l.shape).each(function(a, b) {
        var c = e.select(this);
        c.classed(l.SELECTED) &amp;&amp; i(!1, c.classed(l.SELECTED, !1), a, b)
    }), g.classed(l.SELECTED, !h), i(!h, g, b, c))
}, i.initBrush = function() {
    var a = this,
    b = a.d3;
    a.brush = b.svg.brush().on(&quot;brush&quot;, function() {
        a.redrawForBrush()
    }), a.brush.update = function() {
        return a.context &amp;&amp; a.context.select(&quot;.&quot; + l.brush).call(this), this
    }, a.brush.scale = function(b) {
        return a.config.axis_rotated ? this.y(b) : this.x(b)
    }
}, i.initSubchart = function() {
    var a = this,
    b = a.config,
    c = a.context = a.svg.append(&quot;g&quot;).attr(&quot;transform&quot;, a.getTranslate(&quot;context&quot;)),
    d = b.subchart_show ? &quot;visible&quot; : &quot;hidden&quot;;
    c.style(&quot;visibility&quot;, d), c.append(&quot;g&quot;).attr(&quot;clip-path&quot;, a.clipPathForSubchart).attr(&quot;class&quot;, l.chart), c.select(&quot;.&quot; + l.chart).append(&quot;g&quot;).attr(&quot;class&quot;, l.chartBars), c.select(&quot;.&quot; + l.chart).append(&quot;g&quot;).attr(&quot;class&quot;, l.chartLines), c.append(&quot;g&quot;).attr(&quot;clip-path&quot;, a.clipPath).attr(&quot;class&quot;, l.brush).call(a.brush), a.axes.subx = c.append(&quot;g&quot;).attr(&quot;class&quot;, l.axisX).attr(&quot;transform&quot;, a.getTranslate(&quot;subx&quot;)).attr(&quot;clip-path&quot;, b.axis_rotated ? &quot;&quot; : a.clipPathForXAxis).style(&quot;visibility&quot;, b.subchart_axis_x_show ? d : &quot;hidden&quot;)
}, i.updateTargetsForSubchart = function(a) {
    var b,
    c,
    d,
    e,
    f = this,
    g = f.context,
    h = f.config,
    i = f.classChartBar.bind(f),
    j = f.classBars.bind(f),
    k = f.classChartLine.bind(f),
    m = f.classLines.bind(f),
    n = f.classAreas.bind(f);
    h.subchart_show &amp;&amp; (e = g.select(&quot;.&quot; + l.chartBars).selectAll(&quot;.&quot; + l.chartBar).data(a).attr(&quot;class&quot;, i), d = e.enter().append(&quot;g&quot;).style(&quot;opacity&quot;, 0).attr(&quot;class&quot;, i), d.append(&quot;g&quot;).attr(&quot;class&quot;, j), c = g.select(&quot;.&quot; + l.chartLines).selectAll(&quot;.&quot; + l.chartLine).data(a).attr(&quot;class&quot;, k), b = c.enter().append(&quot;g&quot;).style(&quot;opacity&quot;, 0).attr(&quot;class&quot;, k), b.append(&quot;g&quot;).attr(&quot;class&quot;, m), b.append(&quot;g&quot;).attr(&quot;class&quot;, n), g.selectAll(&quot;.&quot; + l.brush + &quot; rect&quot;).attr(h.axis_rotated ? &quot;width&quot; : &quot;height&quot;, h.axis_rotated ? f.width2 : f.height2))
}, i.updateBarForSubchart = function(a) {
    var b = this;
    b.contextBar = b.context.selectAll(&quot;.&quot; + l.bars).selectAll(&quot;.&quot; + l.bar).data(b.barData.bind(b)), b.contextBar.enter().append(&quot;path&quot;).attr(&quot;class&quot;, b.classBar.bind(b)).style(&quot;stroke&quot;, &quot;none&quot;).style(&quot;fill&quot;, b.color), b.contextBar.style(&quot;opacity&quot;, b.initialOpacity.bind(b)), b.contextBar.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove()
}, i.redrawBarForSubchart = function(a, b, c) {
    (b ? this.contextBar.transition(Math.random().toString()).duration(c) : this.contextBar).attr(&quot;d&quot;, a).style(&quot;opacity&quot;, 1)
}, i.updateLineForSubchart = function(a) {
    var b = this;
    b.contextLine = b.context.selectAll(&quot;.&quot; + l.lines).selectAll(&quot;.&quot; + l.line).data(b.lineData.bind(b)), b.contextLine.enter().append(&quot;path&quot;).attr(&quot;class&quot;, b.classLine.bind(b)).style(&quot;stroke&quot;, b.color), b.contextLine.style(&quot;opacity&quot;, b.initialOpacity.bind(b)), b.contextLine.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove()
}, i.redrawLineForSubchart = function(a, b, c) {
    (b ? this.contextLine.transition(Math.random().toString()).duration(c) : this.contextLine).attr(&quot;d&quot;, a).style(&quot;opacity&quot;, 1)
}, i.updateAreaForSubchart = function(a) {
    var b = this,
    c = b.d3;
    b.contextArea = b.context.selectAll(&quot;.&quot; + l.areas).selectAll(&quot;.&quot; + l.area).data(b.lineData.bind(b)), b.contextArea.enter().append(&quot;path&quot;).attr(&quot;class&quot;, b.classArea.bind(b)).style(&quot;fill&quot;, b.color).style(&quot;opacity&quot;, function() {
        return b.orgAreaOpacity = +c.select(this).style(&quot;opacity&quot;), 0
    }), b.contextArea.style(&quot;opacity&quot;, 0), b.contextArea.exit().transition().duration(a).style(&quot;opacity&quot;, 0).remove()
}, i.redrawAreaForSubchart = function(a, b, c) {
    (b ? this.contextArea.transition(Math.random().toString()).duration(c) : this.contextArea).attr(&quot;d&quot;, a).style(&quot;fill&quot;, this.color).style(&quot;opacity&quot;, this.orgAreaOpacity)
}, i.redrawSubchart = function(a, b, c, d, e, f, g) {
    var h,
    i,
    j,
    k = this,
    l = k.d3,
    m = k.config;
    k.context.style(&quot;visibility&quot;, m.subchart_show ? &quot;visible&quot; : &quot;hidden&quot;), m.subchart_show &amp;&amp; (l.event &amp;&amp; &quot;zoom&quot; === l.event.type &amp;&amp; k.brush.extent(k.x.orgDomain()).update(), a &amp;&amp; (k.brush.empty() || k.brush.extent(k.x.orgDomain()).update(), h = k.generateDrawArea(e, !0), i = k.generateDrawBar(f, !0), j = k.generateDrawLine(g, !0), k.updateBarForSubchart(c), k.updateLineForSubchart(c), k.updateAreaForSubchart(c), k.redrawBarForSubchart(i, c, c), k.redrawLineForSubchart(j, c, c), k.redrawAreaForSubchart(h, c, c)))
}, i.redrawForBrush = function() {
    var a = this,
    b = a.x;
    a.redraw({
        withTransition: !1,
        withY: a.config.zoom_rescale,
        withSubchart: !1,
        withUpdateXDomain: !0,
        withDimension: !1
    }), a.config.subchart_onbrush.call(a.api, b.orgDomain())
}, i.transformContext = function(a, b) {
    var c,
    d = this;
    b &amp;&amp; b.axisSubX ? c = b.axisSubX : (c = d.context.select(&quot;.&quot; + l.axisX), a &amp;&amp; (c = c.transition())), d.context.attr(&quot;transform&quot;, d.getTranslate(&quot;context&quot;)), c.attr(&quot;transform&quot;, d.getTranslate(&quot;subx&quot;))
}, i.getDefaultExtent = function() {
    var a = this,
    b = a.config,
    c = n(b.axis_x_extent) ? b.axis_x_extent(a.getXDomain(a.data.targets)) : b.axis_x_extent;
    return a.isTimeSeries() &amp;&amp; (c = [a.parseDate(c[0]), a.parseDate(c[1])]), c
}, i.initZoom = function() {
    var a,
    b = this,
    c = b.d3,
    d = b.config;
    b.zoom = c.behavior.zoom().on(&quot;zoomstart&quot;, function() {
        a = c.event.sourceEvent, b.zoom.altDomain = c.event.sourceEvent.altKey ? b.x.orgDomain() : null, d.zoom_onzoomstart.call(b.api, c.event.sourceEvent)
    }).on(&quot;zoom&quot;, function() {
        b.redrawForZoom.call(b)
    }).on(&quot;zoomend&quot;, function() {
        var e = c.event.sourceEvent;
        e &amp;&amp; a.clientX === e.clientX &amp;&amp; a.clientY === e.clientY || (b.redrawEventRect(), b.updateZoom(), d.zoom_onzoomend.call(b.api, b.x.orgDomain()))
    }), b.zoom.scale = function(a) {
        return d.axis_rotated ? this.y(a) : this.x(a)
    }, b.zoom.orgScaleExtent = function() {
        var a = d.zoom_extent ? d.zoom_extent : [1, 10];
        return [a[0], Math.max(b.getMaxDataCount() / a[1], a[1])]
    }, b.zoom.updateScaleExtent = function() {
        var a = t(b.x.orgDomain()) / t(b.getZoomDomain()),
        c = this.orgScaleExtent();
        return this.scaleExtent([c[0] * a, c[1] * a]), this
    }
}, i.getZoomDomain = function() {
    var a = this,
    b = a.config,
    c = a.d3,
    d = c.min([a.orgXDomain[0], b.zoom_x_min]),
    e = c.max([a.orgXDomain[1], b.zoom_x_max]);
    return [d, e]
}, i.updateZoom = function() {
    var a = this,
    b = a.config.zoom_enabled ? a.zoom : function() {};
    a.main.select(&quot;.&quot; + l.zoomRect).call(b).on(&quot;dblclick.zoom&quot;, null), a.main.selectAll(&quot;.&quot; + l.eventRect).call(b).on(&quot;dblclick.zoom&quot;, null)
}, i.redrawForZoom = function() {
    var a = this,
    b = a.d3,
    c = a.config,
    d = a.zoom,
    e = a.x;
    if (c.zoom_enabled &amp;&amp; 0 !== a.filterTargetsToShow(a.data.targets).length) {
        if (&quot;mousemove&quot; === b.event.sourceEvent.type &amp;&amp; d.altDomain)
        return e.domain(d.altDomain), void d.scale(e).updateScaleExtent();
        a.isCategorized() &amp;&amp; e.orgDomain()[0] === a.orgXDomain[0] &amp;&amp; e.domain([a.orgXDomain[0] - 1e-10, e.orgDomain()[1]]), a.redraw({
            withTransition: !1,
            withY: c.zoom_rescale,
            withSubchart: !1,
            withEventRect: !1,
            withDimension: !1
        }), &quot;mousemove&quot; === b.event.sourceEvent.type &amp;&amp; (a.cancelClick = !0), c.zoom_onzoom.call(a.api, e.orgDomain())
    }
}, i.generateColor = function() {
    var a = this,
    b = a.config,
    c = a.d3,
    d = b.data_colors,
    e = v(b.color_pattern) ? b.color_pattern : c.scale.category10().range(),
    f = b.data_color,
    g = [];
    return function(a) {
        var b,
        c = a.id || a.data &amp;&amp; a.data.id || a;
        return d[c] instanceof Function ? b = d[c](a) : d[c] ? b = d[c] : (g.indexOf(c) &lt; 0 &amp;&amp; g.push(c), b = e[g.indexOf(c) % e.length], d[c] = b), f instanceof Function ? f(b, a) : b
    }
}, i.generateLevelColor = function() {
    var a = this,
    b = a.config,
    c = b.color_pattern,
    d = b.color_threshold,
    e = &quot;value&quot; === d.unit,
    f = d.values &amp;&amp; d.values.length ? d.values : [],
    g = d.max || 100;
    return v(b.color_threshold) ? function(a) {
        var b,
        d,
        h = c[c.length - 1];
        for (b = 0; b &lt; f.length; b++)
        if (d = e ? a : 100 * a / g, d &lt; f[b]) {
            h = c[b];
            break
        }
        return h
    } : null
}, i.getYFormat = function(a) {
    var b = this,
    c = a &amp;&amp; !b.hasType(&quot;gauge&quot;) ? b.defaultArcValueFormat : b.yFormat,
    d = a &amp;&amp; !b.hasType(&quot;gauge&quot;) ? b.defaultArcValueFormat : b.y2Format;
    return function(a, e, f) {
        var g = &quot;y2&quot; === b.axis.getId(f) ? d : c;
        return g.call(b, a, e)
    }
}, i.yFormat = function(a) {
    var b = this,
    c = b.config,
    d = c.axis_y_tick_format ? c.axis_y_tick_format : b.defaultValueFormat;
    return d(a)
}, i.y2Format = function(a) {
    var b = this,
    c = b.config,
    d = c.axis_y2_tick_format ? c.axis_y2_tick_format : b.defaultValueFormat;
    return d(a)
}, i.defaultValueFormat = function(a) {
    return m(a) ? +a : &quot;&quot;
}, i.defaultArcValueFormat = function(a, b) {
    return (100 * b).toFixed(1) + &quot;%&quot;
}, i.dataLabelFormat = function(a) {
    var b,
    c = this,
    d = c.config.data_labels,
    e = function(a) {
        return m(a) ? +a : &quot;&quot;
    };
    return b = &quot;function&quot; == typeof d.format ? d.format : &quot;object&quot; == typeof d.format ? d.format[a] ? d.format[a] === !0 ? e : d.format[a] : function() {
        return &quot;&quot;
    } : e
}, i.hasCaches = function(a) {
    for (var b = 0; b &lt; a.length; b++)
    if (!(a[b] in this.cache))
    return !1;
    return !0
}, i.addCache = function(a, b) {
    this.cache[a] = this.cloneTarget(b)
}, i.getCaches = function(a) {
    var b,
    c = [];
    for (b = 0; b &lt; a.length; b++)
    a[b] in this.cache &amp;&amp; c.push(this.cloneTarget(this.cache[a[b]]));
    return c
};
var l = i.CLASS = {
    target: &quot;c3-target&quot;,
    chart: &quot;c3-chart&quot;,
    chartLine: &quot;c3-chart-line&quot;,
    chartLines: &quot;c3-chart-lines&quot;,
    chartBar: &quot;c3-chart-bar&quot;,
    chartBars: &quot;c3-chart-bars&quot;,
    chartText: &quot;c3-chart-text&quot;,
    chartTexts: &quot;c3-chart-texts&quot;,
    chartArc: &quot;c3-chart-arc&quot;,
    chartArcs: &quot;c3-chart-arcs&quot;,
    chartArcsTitle: &quot;c3-chart-arcs-title&quot;,
    chartArcsBackground: &quot;c3-chart-arcs-background&quot;,
    chartArcsGaugeUnit: &quot;c3-chart-arcs-gauge-unit&quot;,
    chartArcsGaugeMax: &quot;c3-chart-arcs-gauge-max&quot;,
    chartArcsGaugeMin: &quot;c3-chart-arcs-gauge-min&quot;,
    selectedCircle: &quot;c3-selected-circle&quot;,
    selectedCircles: &quot;c3-selected-circles&quot;,
    eventRect: &quot;c3-event-rect&quot;,
    eventRects: &quot;c3-event-rects&quot;,
    eventRectsSingle: &quot;c3-event-rects-single&quot;,
    eventRectsMultiple: &quot;c3-event-rects-multiple&quot;,
    zoomRect: &quot;c3-zoom-rect&quot;,
    brush: &quot;c3-brush&quot;,
    focused: &quot;c3-focused&quot;,
    defocused: &quot;c3-defocused&quot;,
    region: &quot;c3-region&quot;,
    regions: &quot;c3-regions&quot;,
    title: &quot;c3-title&quot;,
    tooltipContainer: &quot;c3-tooltip-container&quot;,
    tooltip: &quot;c3-tooltip&quot;,
    tooltipName: &quot;c3-tooltip-name&quot;,
    shape: &quot;c3-shape&quot;,
    shapes: &quot;c3-shapes&quot;,
    line: &quot;c3-line&quot;,
    lines: &quot;c3-lines&quot;,
    bar: &quot;c3-bar&quot;,
    bars: &quot;c3-bars&quot;,
    circle: &quot;c3-circle&quot;,
    circles: &quot;c3-circles&quot;,
    arc: &quot;c3-arc&quot;,
    arcs: &quot;c3-arcs&quot;,
    area: &quot;c3-area&quot;,
    areas: &quot;c3-areas&quot;,
    empty: &quot;c3-empty&quot;,
    text: &quot;c3-text&quot;,
    texts: &quot;c3-texts&quot;,
    gaugeValue: &quot;c3-gauge-value&quot;,
    grid: &quot;c3-grid&quot;,
    gridLines: &quot;c3-grid-lines&quot;,
    xgrid: &quot;c3-xgrid&quot;,
    xgrids: &quot;c3-xgrids&quot;,
    xgridLine: &quot;c3-xgrid-line&quot;,
    xgridLines: &quot;c3-xgrid-lines&quot;,
    xgridFocus: &quot;c3-xgrid-focus&quot;,
    ygrid: &quot;c3-ygrid&quot;,
    ygrids: &quot;c3-ygrids&quot;,
    ygridLine: &quot;c3-ygrid-line&quot;,
    ygridLines: &quot;c3-ygrid-lines&quot;,
    axis: &quot;c3-axis&quot;,
    axisX: &quot;c3-axis-x&quot;,
    axisXLabel: &quot;c3-axis-x-label&quot;,
    axisY: &quot;c3-axis-y&quot;,
    axisYLabel: &quot;c3-axis-y-label&quot;,
    axisY2: &quot;c3-axis-y2&quot;,
    axisY2Label: &quot;c3-axis-y2-label&quot;,
    legendBackground: &quot;c3-legend-background&quot;,
    legendItem: &quot;c3-legend-item&quot;,
    legendItemEvent: &quot;c3-legend-item-event&quot;,
    legendItemTile: &quot;c3-legend-item-tile&quot;,
    legendItemHidden: &quot;c3-legend-item-hidden&quot;,
    legendItemFocused: &quot;c3-legend-item-focused&quot;,
    dragarea: &quot;c3-dragarea&quot;,
    EXPANDED: &quot;_expanded_&quot;,
    SELECTED: &quot;_selected_&quot;,
    INCLUDED: &quot;_included_&quot;
};
i.generateClass = function(a, b) {
    return &quot; &quot; + a + &quot; &quot; + a + this.getTargetSelectorSuffix(b)
}, i.classText = function(a) {
    return this.generateClass(l.text, a.index)
}, i.classTexts = function(a) {
    return this.generateClass(l.texts, a.id)
}, i.classShape = function(a) {
    return this.generateClass(l.shape, a.index)
}, i.classShapes = function(a) {
    return this.generateClass(l.shapes, a.id)
}, i.classLine = function(a) {
    return this.classShape(a) + this.generateClass(l.line, a.id)
}, i.classLines = function(a) {
    return this.classShapes(a) + this.generateClass(l.lines, a.id)
}, i.classCircle = function(a) {
    return this.classShape(a) + this.generateClass(l.circle, a.index)
}, i.classCircles = function(a) {
    return this.classShapes(a) + this.generateClass(l.circles, a.id)
}, i.classBar = function(a) {
    return this.classShape(a) + this.generateClass(l.bar, a.index)
}, i.classBars = function(a) {
    return this.classShapes(a) + this.generateClass(l.bars, a.id)
}, i.classArc = function(a) {
    return this.classShape(a.data) + this.generateClass(l.arc, a.data.id)
}, i.classArcs = function(a) {
    return this.classShapes(a.data) + this.generateClass(l.arcs, a.data.id)
}, i.classArea = function(a) {
    return this.classShape(a) + this.generateClass(l.area, a.id)
}, i.classAreas = function(a) {
    return this.classShapes(a) + this.generateClass(l.areas, a.id)
}, i.classRegion = function(a, b) {
    return this.generateClass(l.region, b) + &quot; &quot; + (&quot;class&quot; in a ? a[&quot;class&quot;] : &quot;&quot;)
}, i.classEvent = function(a) {
    return this.generateClass(l.eventRect, a.index)
}, i.classTarget = function(a) {
    var b = this,
    c = b.config.data_classes[a],
    d = &quot;&quot;;
    return c &amp;&amp; (d = &quot; &quot; + l.target + &quot;-&quot; + c), b.generateClass(l.target, a) + d
}, i.classFocus = function(a) {
    return this.classFocused(a) + this.classDefocused(a)
}, i.classFocused = function(a) {
    return &quot; &quot; + (this.focusedTargetIds.indexOf(a.id) &gt;= 0 ? l.focused : &quot;&quot;)
}, i.classDefocused = function(a) {
    return &quot; &quot; + (this.defocusedTargetIds.indexOf(a.id) &gt;= 0 ? l.defocused : &quot;&quot;)
}, i.classChartText = function(a) {
    return l.chartText + this.classTarget(a.id)
}, i.classChartLine = function(a) {
    return l.chartLine + this.classTarget(a.id)
}, i.classChartBar = function(a) {
    return l.chartBar + this.classTarget(a.id)
}, i.classChartArc = function(a) {
    return l.chartArc + this.classTarget(a.data.id)
}, i.getTargetSelectorSuffix = function(a) {
    return a || 0 === a ? (&quot;-&quot; + a).replace(/[\s?!@#$%^&amp;*()_=+,.&lt;&gt;&#39;&quot;:;\[\]\/|~`{}\\]/g, &quot;-&quot;) : &quot;&quot;
}, i.selectorTarget = function(a, b) {
    return (b || &quot;&quot;) + &quot;.&quot; + l.target + this.getTargetSelectorSuffix(a)
}, i.selectorTargets = function(a, b) {
    var c = this;
    return a = a || [], a.length ? a.map(function(a) {
        return c.selectorTarget(a, b)
    }) : null
}, i.selectorLegend = function(a) {
    return &quot;.&quot; + l.legendItem + this.getTargetSelectorSuffix(a)
}, i.selectorLegends = function(a) {
    var b = this;
    return a &amp;&amp; a.length ? a.map(function(a) {
        return b.selectorLegend(a)
    }) : null
};
var m = i.isValue = function(a) {
    return a || 0 === a
},
n = i.isFunction = function(a) {
    return &quot;function&quot; == typeof a
},
o = i.isString = function(a) {
    return &quot;string&quot; == typeof a
},
p = i.isUndefined = function(a) {
    return &quot;undefined&quot; == typeof a
},
q = i.isDefined = function(a) {
    return &quot;undefined&quot; != typeof a
},
r = i.ceil10 = function(a) {
    return 10 * Math.ceil(a / 10)
},
s = i.asHalfPixel = function(a) {
    return Math.ceil(a) + .5
},
t = i.diffDomain = function(a) {
    return a[1] - a[0]
},
u = i.isEmpty = function(a) {
    return &quot;undefined&quot; == typeof a || null === a || o(a) &amp;&amp; 0 === a.length || &quot;object&quot; == typeof a &amp;&amp; 0 === Object.keys(a).length
},
v = i.notEmpty = function(a) {
    return !i.isEmpty(a)
},
w = i.getOption = function(a, b, c) {
    return q(a[b]) ? a[b] : c
},
x = i.hasValue = function(a, b) {
    var c = !1;
    return Object.keys(a).forEach(function(d) {
        a[d] === b &amp;&amp; (c = !0)
    }), c
},
y = i.sanitise = function(a) {
    return &quot;string&quot; == typeof a ? a.replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;) : a
},
z = i.getPathBox = function(a) {
    var b = a.getBoundingClientRect(),
    c = [a.pathSegList.getItem(0), a.pathSegList.getItem(1)],
    d = c[0].x,
    e = Math.min(c[0].y, c[1].y);
    return {
        x: d,
        y: e,
        width: b.width,
        height: b.height
    }
};
h.focus = function(a) {
    var b,
    c = this.internal;
    a = c.mapToTargetIds(a), b = c.svg.selectAll(c.selectorTargets(a.filter(c.isTargetToShow, c))), this.revert(), this.defocus(), b.classed(l.focused, !0).classed(l.defocused, !1),
    c.hasArcType() &amp;&amp; c.expandArc(a), c.toggleFocusLegend(a, !0), c.focusedTargetIds = a, c.defocusedTargetIds = c.defocusedTargetIds.filter(function(b) {
        return a.indexOf(b) &lt; 0
    })
}, h.defocus = function(a) {
    var b,
    c = this.internal;
    a = c.mapToTargetIds(a), b = c.svg.selectAll(c.selectorTargets(a.filter(c.isTargetToShow, c))), b.classed(l.focused, !1).classed(l.defocused, !0), c.hasArcType() &amp;&amp; c.unexpandArc(a), c.toggleFocusLegend(a, !1), c.focusedTargetIds = c.focusedTargetIds.filter(function(b) {
        return a.indexOf(b) &lt; 0
    }), c.defocusedTargetIds = a
}, h.revert = function(a) {
    var b,
    c = this.internal;
    a = c.mapToTargetIds(a), b = c.svg.selectAll(c.selectorTargets(a)), b.classed(l.focused, !1).classed(l.defocused, !1), c.hasArcType() &amp;&amp; c.unexpandArc(a), c.config.legend_show &amp;&amp; (c.showLegend(a.filter(c.isLegendToShow.bind(c))), c.legend.selectAll(c.selectorLegends(a)).filter(function() {
        return c.d3.select(this).classed(l.legendItemFocused)
    }).classed(l.legendItemFocused, !1)), c.focusedTargetIds = [], c.defocusedTargetIds = []
}, h.show = function(a, b) {
    var c,
    d = this.internal;
    a = d.mapToTargetIds(a), b = b || {}, d.removeHiddenTargetIds(a), c = d.svg.selectAll(d.selectorTargets(a)), c.transition().style(&quot;opacity&quot;, 1, &quot;important&quot;).call(d.endall, function() {
        c.style(&quot;opacity&quot;, null).style(&quot;opacity&quot;, 1)
    }), b.withLegend &amp;&amp; d.showLegend(a), d.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
    })
}, h.hide = function(a, b) {
    var c,
    d = this.internal;
    a = d.mapToTargetIds(a), b = b || {}, d.addHiddenTargetIds(a), c = d.svg.selectAll(d.selectorTargets(a)), c.transition().style(&quot;opacity&quot;, 0, &quot;important&quot;).call(d.endall, function() {
        c.style(&quot;opacity&quot;, null).style(&quot;opacity&quot;, 0)
    }), b.withLegend &amp;&amp; d.hideLegend(a), d.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
    })
}, h.toggle = function(a, b) {
    var c = this,
    d = this.internal;
    d.mapToTargetIds(a).forEach(function(a) {
        d.isTargetToShow(a) ? c.hide(a, b) : c.show(a, b)
    })
}, h.zoom = function(a) {
    var b = this.internal;
    return a &amp;&amp; (b.isTimeSeries() &amp;&amp; (a = a.map(function(a) {
        return b.parseDate(a)
    })), b.brush.extent(a), b.redraw({
        withUpdateXDomain: !0,
        withY: b.config.zoom_rescale
    }), b.config.zoom_onzoom.call(this, b.x.orgDomain())), b.brush.extent()
}, h.zoom.enable = function(a) {
    var b = this.internal;
    b.config.zoom_enabled = a, b.updateAndRedraw()
}, h.unzoom = function() {
    var a = this.internal;
    a.brush.clear().update(), a.redraw({
        withUpdateXDomain: !0
    })
}, h.zoom.max = function(a) {
    var b = this.internal,
    c = b.config,
    d = b.d3;
    return 0 === a || a ? void (c.zoom_x_max = d.max([b.orgXDomain[1], a])) : c.zoom_x_max
}, h.zoom.min = function(a) {
    var b = this.internal,
    c = b.config,
    d = b.d3;
    return 0 === a || a ? void (c.zoom_x_min = d.min([b.orgXDomain[0], a])) : c.zoom_x_min
}, h.zoom.range = function(a) {
    return arguments.length ? (q(a.max) &amp;&amp; this.domain.max(a.max), void (q(a.min) &amp;&amp; this.domain.min(a.min))) : {
        max: this.domain.max(),
        min: this.domain.min()
    }
}, h.load = function(a) {
    var b = this.internal,
    c = b.config;
    return a.xs &amp;&amp; b.addXs(a.xs), &quot;names&quot; in a &amp;&amp; h.data.names.bind(this)(a.names), &quot;classes&quot; in a &amp;&amp; Object.keys(a.classes).forEach(function(b) {
        c.data_classes[b] = a.classes[b]
    }), &quot;categories&quot; in a &amp;&amp; b.isCategorized() &amp;&amp; (c.axis_x_categories = a.categories), &quot;axes&quot; in a &amp;&amp; Object.keys(a.axes).forEach(function(b) {
        c.data_axes[b] = a.axes[b]
    }), &quot;colors&quot; in a &amp;&amp; Object.keys(a.colors).forEach(function(b) {
        c.data_colors[b] = a.colors[b]
    }), &quot;cacheIds&quot; in a &amp;&amp; b.hasCaches(a.cacheIds) ? void b.load(b.getCaches(a.cacheIds), a.done) : void (&quot;unload&quot; in a ? b.unload(b.mapToTargetIds(&quot;boolean&quot; == typeof a.unload &amp;&amp; a.unload ? null : a.unload), function() {
        b.loadFromArgs(a)
    }) : b.loadFromArgs(a))
}, h.unload = function(a) {
    var b = this.internal;
    a = a || {}, a instanceof Array ? a = {
        ids: a
    } : &quot;string&quot; == typeof a &amp;&amp; (a = {
        ids: [a]
    }), b.unload(b.mapToTargetIds(a.ids), function() {
        b.redraw({
            withUpdateOrgXDomain: !0,
            withUpdateXDomain: !0,
            withLegend: !0
        }), a.done &amp;&amp; a.done()
    })
}, h.flow = function(a) {
    var b,
    c,
    d,
    e,
    f,
    g,
    h,
    i,
    j = this.internal,
    k = [],
    l = j.getMaxDataCount(),
    n = 0,
    o = 0;
    if (a.json)
    c = j.convertJsonToData(a.json, a.keys);
    else if (a.rows)
    c = j.convertRowsToData(a.rows);
    else {
        if (!a.columns)
        return;
        c = j.convertColumnsToData(a.columns)
    }
    b = j.convertDataToTargets(c, !0), j.data.targets.forEach(function(a) {
        var c,
        d,
        e = !1;
        for (c = 0; c &lt; b.length; c++)
        if (a.id === b[c].id) {
            for (e = !0, a.values[a.values.length - 1] &amp;&amp; (o = a.values[a.values.length - 1].index + 1), n = b[c].values.length, d = 0; n &gt; d; d++)
            b[c].values[d].index = o + d, j.isTimeSeries() || (b[c].values[d].x = o + d);
            a.values = a.values.concat(b[c].values), b.splice(c, 1);
            break
        }
        e || k.push(a.id)
    }), j.data.targets.forEach(function(a) {
        var b,
        c;
        for (b = 0; b &lt; k.length; b++)
        if (a.id === k[b])
        for (o = a.values[a.values.length - 1].index + 1, c = 0; n &gt; c; c++)
        a.values.push({
            id: a.id,
            index: o + c,
            x: j.isTimeSeries() ? j.getOtherTargetX(o + c) : o + c,
            value: null
        })
    }), j.data.targets.length &amp;&amp; b.forEach(function(a) {
        var b,
        c = [];
        for (b = j.data.targets[0].values[0].index; o &gt; b; b++)
        c.push({
            id: a.id,
            index: b,
            x: j.isTimeSeries() ? j.getOtherTargetX(b) : b,
            value: null
        });
        a.values.forEach(function(a) {
            a.index += o, j.isTimeSeries() || (a.x += o)
        }), a.values = c.concat(a.values)
    }), j.data.targets = j.data.targets.concat(b), d = j.getMaxDataCount(), f = j.data.targets[0], g = f.values[0], q(a.to) ? (n = 0, i = j.isTimeSeries() ? j.parseDate(a.to) : a.to, f.values.forEach(function(a) {
        a.x &lt; i &amp;&amp; n++
    })) : q(a.length) &amp;&amp; (n = a.length), l ? 1 === l &amp;&amp; j.isTimeSeries() &amp;&amp; (h = (f.values[f.values.length - 1].x - g.x) / 2, e = [new Date(+g.x - h), new Date(+g.x + h)], j.updateXDomain(null, !0, !0, !1, e)) : (h = j.isTimeSeries() ? f.values.length &gt; 1 ? f.values[f.values.length - 1].x - g.x : g.x - j.getXDomain(j.data.targets)[0] : 1, e = [g.x - h, g.x], j.updateXDomain(null, !0, !0, !1, e)), j.updateTargets(j.data.targets), j.redraw({
        flow: {
            index: g.index,
            length: n,
            duration: m(a.duration) ? a.duration : j.config.transition_duration,
            done: a.done,
            orgDataCount: l
        },
        withLegend: !0,
        withTransition: l &gt; 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
    })
}, i.generateFlow = function(a) {
    var b = this,
    c = b.config,
    d = b.d3;
    return function() {
        var e,
        f,
        g,
        h = a.targets,
        i = a.flow,
        j = a.drawBar,
        k = a.drawLine,
        m = a.drawArea,
        n = a.cx,
        o = a.cy,
        p = a.xv,
        q = a.xForText,
        r = a.yForText,
        s = a.duration,
        u = 1,
        v = i.index,
        w = i.length,
        x = b.getValueOnIndex(b.data.targets[0].values, v),
        y = b.getValueOnIndex(b.data.targets[0].values, v + w),
        z = b.x.domain(),
        A = i.duration || s,
        B = i.done || function() {},
        C = b.generateWait(),
        D = b.xgrid || d.selectAll([]),
        E = b.xgridLines || d.selectAll([]),
        F = b.mainRegion || d.selectAll([]),
        G = b.mainText || d.selectAll([]),
        H = b.mainBar || d.selectAll([]),
        I = b.mainLine || d.selectAll([]),
        J = b.mainArea || d.selectAll([]),
        K = b.mainCircle || d.selectAll([]);
        b.flowing = !0, b.data.targets.forEach(function(a) {
            a.values.splice(0, w)
        }), g = b.updateXDomain(h, !0, !0), b.updateXGrid &amp;&amp; b.updateXGrid(!0), i.orgDataCount ? e = 1 === i.orgDataCount || (x &amp;&amp; x.x) === (y &amp;&amp; y.x) ? b.x(z[0]) - b.x(g[0]) : b.isTimeSeries() ? b.x(z[0]) - b.x(g[0]) : b.x(x.x) - b.x(y.x) : 1 !== b.data.targets[0].values.length ? e = b.x(z[0]) - b.x(g[0]) : b.isTimeSeries() ? (x = b.getValueOnIndex(b.data.targets[0].values, 0), y = b.getValueOnIndex(b.data.targets[0].values, b.data.targets[0].values.length - 1), e = b.x(x.x) - b.x(y.x)) : e = t(g) / 2, u = t(z) / t(g), f = &quot;translate(&quot; + e + &quot;,0) scale(&quot; + u + &quot;,1)&quot;, b.hideXGridFocus(), d.transition().ease(&quot;linear&quot;).duration(A).each(function() {
            C.add(b.axes.x.transition().call(b.xAxis)), C.add(H.transition().attr(&quot;transform&quot;, f)), C.add(I.transition().attr(&quot;transform&quot;, f)), C.add(J.transition().attr(&quot;transform&quot;, f)), C.add(K.transition().attr(&quot;transform&quot;, f)), C.add(G.transition().attr(&quot;transform&quot;, f)), C.add(F.filter(b.isRegionOnX).transition().attr(&quot;transform&quot;, f)), C.add(D.transition().attr(&quot;transform&quot;, f)), C.add(E.transition().attr(&quot;transform&quot;, f))
        }).call(C, function() {
            var a,
            d = [],
            e = [],
            f = [];
            if (w) {
                for (a = 0; w &gt; a; a++)
                d.push(&quot;.&quot; + l.shape + &quot;-&quot; + (v + a)), e.push(&quot;.&quot; + l.text + &quot;-&quot; + (v + a)), f.push(&quot;.&quot; + l.eventRect + &quot;-&quot; + (v + a));
                b.svg.selectAll(&quot;.&quot; + l.shapes).selectAll(d).remove(), b.svg.selectAll(&quot;.&quot; + l.texts).selectAll(e).remove(), b.svg.selectAll(&quot;.&quot; + l.eventRects).selectAll(f).remove(), b.svg.select(&quot;.&quot; + l.xgrid).remove()
            }
            D.attr(&quot;transform&quot;, null).attr(b.xgridAttr), E.attr(&quot;transform&quot;, null), E.select(&quot;line&quot;).attr(&quot;x1&quot;, c.axis_rotated ? 0 : p).attr(&quot;x2&quot;, c.axis_rotated ? b.width : p), E.select(&quot;text&quot;).attr(&quot;x&quot;, c.axis_rotated ? b.width : 0).attr(&quot;y&quot;, p), H.attr(&quot;transform&quot;, null).attr(&quot;d&quot;, j), I.attr(&quot;transform&quot;, null).attr(&quot;d&quot;, k), J.attr(&quot;transform&quot;, null).attr(&quot;d&quot;, m), K.attr(&quot;transform&quot;, null).attr(&quot;cx&quot;, n).attr(&quot;cy&quot;, o), G.attr(&quot;transform&quot;, null).attr(&quot;x&quot;, q).attr(&quot;y&quot;, r).style(&quot;fill-opacity&quot;, b.opacityForText.bind(b)), F.attr(&quot;transform&quot;, null), F.select(&quot;rect&quot;).filter(b.isRegionOnX).attr(&quot;x&quot;, b.regionX.bind(b)).attr(&quot;width&quot;, b.regionWidth.bind(b)), c.interaction_enabled &amp;&amp; b.redrawEventRect(), B(), b.flowing = !1
        })
    }
}, h.selected = function(a) {
    var b = this.internal,
    c = b.d3;
    return c.merge(b.main.selectAll(&quot;.&quot; + l.shapes + b.getTargetSelectorSuffix(a)).selectAll(&quot;.&quot; + l.shape).filter(function() {
        return c.select(this).classed(l.SELECTED)
    }).map(function(a) {
        return a.map(function(a) {
            var b = a.__data__;
            return b.data ? b.data : b
        })
    }))
}, h.select = function(a, b, c) {
    var d = this.internal,
    e = d.d3,
    f = d.config;
    f.data_selection_enabled &amp;&amp; d.main.selectAll(&quot;.&quot; + l.shapes).selectAll(&quot;.&quot; + l.shape).each(function(g, h) {
        var i = e.select(this),
        j = g.data ? g.data.id : g.id,
        k = d.getToggle(this, g).bind(d),
        m = f.data_selection_grouped || !a || a.indexOf(j) &gt;= 0,
        n = !b || b.indexOf(h) &gt;= 0,
        o = i.classed(l.SELECTED);
        i.classed(l.line) || i.classed(l.area) || (m &amp;&amp; n ? f.data_selection_isselectable(g) &amp;&amp; !o &amp;&amp; k(!0, i.classed(l.SELECTED, !0), g, h) : q(c) &amp;&amp; c &amp;&amp; o &amp;&amp; k(!1, i.classed(l.SELECTED, !1), g, h))
    })
}, h.unselect = function(a, b) {
    var c = this.internal,
    d = c.d3,
    e = c.config;
    e.data_selection_enabled &amp;&amp; c.main.selectAll(&quot;.&quot; + l.shapes).selectAll(&quot;.&quot; + l.shape).each(function(f, g) {
        var h = d.select(this),
        i = f.data ? f.data.id : f.id,
        j = c.getToggle(this, f).bind(c),
        k = e.data_selection_grouped || !a || a.indexOf(i) &gt;= 0,
        m = !b || b.indexOf(g) &gt;= 0,
        n = h.classed(l.SELECTED);
        h.classed(l.line) || h.classed(l.area) || k &amp;&amp; m &amp;&amp; e.data_selection_isselectable(f) &amp;&amp; n &amp;&amp; j(!1, h.classed(l.SELECTED, !1), f, g)
    })
}, h.transform = function(a, b) {
    var c = this.internal,
    d = [&quot;pie&quot;, &quot;donut&quot;].indexOf(a) &gt;= 0 ? {
        withTransform: !0
    } : null;
    c.transformTo(b, a, d)
}, i.transformTo = function(a, b, c) {
    var d = this,
    e = !d.hasArcType(),
    f = c || {
        withTransitionForAxis: e
    };
    f.withTransitionForTransform = !1, d.transiting = !1, d.setTargetType(a, b), d.updateTargets(d.data.targets), d.updateAndRedraw(f)
}, h.groups = function(a) {
    var b = this.internal,
    c = b.config;
    return p(a) ? c.data_groups : (c.data_groups = a, b.redraw(), c.data_groups)
}, h.xgrids = function(a) {
    var b = this.internal,
    c = b.config;
    return a ? (c.grid_x_lines = a, b.redrawWithoutRescale(), c.grid_x_lines) : c.grid_x_lines
}, h.xgrids.add = function(a) {
    var b = this.internal;
    return this.xgrids(b.config.grid_x_lines.concat(a ? a : []))
}, h.xgrids.remove = function(a) {
    var b = this.internal;
    b.removeGridLines(a, !0)
}, h.ygrids = function(a) {
    var b = this.internal,
    c = b.config;
    return a ? (c.grid_y_lines = a, b.redrawWithoutRescale(), c.grid_y_lines) : c.grid_y_lines
}, h.ygrids.add = function(a) {
    var b = this.internal;
    return this.ygrids(b.config.grid_y_lines.concat(a ? a : []))
}, h.ygrids.remove = function(a) {
    var b = this.internal;
    b.removeGridLines(a, !1)
}, h.regions = function(a) {
    var b = this.internal,
    c = b.config;
    return a ? (c.regions = a, b.redrawWithoutRescale(), c.regions) : c.regions
}, h.regions.add = function(a) {
    var b = this.internal,
    c = b.config;
    return a ? (c.regions = c.regions.concat(a), b.redrawWithoutRescale(), c.regions) : c.regions
}, h.regions.remove = function(a) {
    var b,
    c,
    d,
    e = this.internal,
    f = e.config;
    return a = a || {}, b = e.getOption(a, &quot;duration&quot;, f.transition_duration), c = e.getOption(a, &quot;classes&quot;, [l.region]), d = e.main.select(&quot;.&quot; + l.regions).selectAll(c.map(function(a) {
        return &quot;.&quot; + a
    })), (b ? d.transition().duration(b) : d).style(&quot;opacity&quot;, 0).remove(), f.regions = f.regions.filter(function(a) {
        var b = !1;
        return a[&quot;class&quot;] ? (a[&quot;class&quot;].split(&quot; &quot;).forEach(function(a) {
            c.indexOf(a) &gt;= 0 &amp;&amp; (b = !0)
        }), !b) : !0
    }), f.regions
}, h.data = function(a) {
    var b = this.internal.data.targets;
    return &quot;undefined&quot; == typeof a ? b : b.filter(function(b) {
        return [].concat(a).indexOf(b.id) &gt;= 0
    })
}, h.data.shown = function(a) {
    return this.internal.filterTargetsToShow(this.data(a))
}, h.data.values = function(a) {
    var b,
    c = null;
    return a &amp;&amp; (b = this.data(a), c = b[0] ? b[0].values.map(function(a) {
        return a.value
    }) : null), c
}, h.data.names = function(a) {
    return this.internal.clearLegendItemTextBoxCache(), this.internal.updateDataAttributes(&quot;names&quot;, a)
}, h.data.colors = function(a) {
    return this.internal.updateDataAttributes(&quot;colors&quot;, a)
}, h.data.axes = function(a) {
    return this.internal.updateDataAttributes(&quot;axes&quot;, a)
}, h.category = function(a, b) {
    var c = this.internal,
    d = c.config;
    return arguments.length &gt; 1 &amp;&amp; (d.axis_x_categories[a] = b, c.redraw()), d.axis_x_categories[a]
}, h.categories = function(a) {
    var b = this.internal,
    c = b.config;
    return arguments.length ? (c.axis_x_categories = a, b.redraw(), c.axis_x_categories) : c.axis_x_categories
}, h.color = function(a) {
    var b = this.internal;
    return b.color(a)
}, h.x = function(a) {
    var b = this.internal;
    return arguments.length &amp;&amp; (b.updateTargetX(b.data.targets, a), b.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0
    })), b.data.xs
}, h.xs = function(a) {
    var b = this.internal;
    return arguments.length &amp;&amp; (b.updateTargetXs(b.data.targets, a), b.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0
    })), b.data.xs
}, h.axis = function() {}, h.axis.labels = function(a) {
    var b = this.internal;
    arguments.length &amp;&amp; (Object.keys(a).forEach(function(c) {
        b.axis.setLabelText(c, a[c])
    }), b.axis.updateLabels())
}, h.axis.max = function(a) {
    var b = this.internal,
    c = b.config;
    return arguments.length ? (&quot;object&quot; == typeof a ? (m(a.x) &amp;&amp; (c.axis_x_max = a.x), m(a.y) &amp;&amp; (c.axis_y_max = a.y), m(a.y2) &amp;&amp; (c.axis_y2_max = a.y2)) : c.axis_y_max = c.axis_y2_max = a, void b.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0
    })) : {
        x: c.axis_x_max,
        y: c.axis_y_max,
        y2: c.axis_y2_max
    }
}, h.axis.min = function(a) {
    var b = this.internal,
    c = b.config;
    return arguments.length ? (&quot;object&quot; == typeof a ? (m(a.x) &amp;&amp; (c.axis_x_min = a.x), m(a.y) &amp;&amp; (c.axis_y_min = a.y), m(a.y2) &amp;&amp; (c.axis_y2_min = a.y2)) : c.axis_y_min = c.axis_y2_min = a, void b.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0
    })) : {
        x: c.axis_x_min,
        y: c.axis_y_min,
        y2: c.axis_y2_min
    }
}, h.axis.range = function(a) {
    return arguments.length ? (q(a.max) &amp;&amp; this.axis.max(a.max), void (q(a.min) &amp;&amp; this.axis.min(a.min))) : {
        max: this.axis.max(),
        min: this.axis.min()
    }
}, h.legend = function() {}, h.legend.show = function(a) {
    var b = this.internal;
    b.showLegend(b.mapToTargetIds(a)), b.updateAndRedraw({
        withLegend: !0
    })
}, h.legend.hide = function(a) {
    var b = this.internal;
    b.hideLegend(b.mapToTargetIds(a)), b.updateAndRedraw({
        withLegend: !0
    })
}, h.resize = function(a) {
    var b = this.internal,
    c = b.config;
    c.size_width = a ? a.width : null, c.size_height = a ? a.height : null, this.flush()
}, h.flush = function() {
    var a = this.internal;
    a.updateAndRedraw({
        withLegend: !0,
        withTransition: !1,
        withTransitionForTransform: !1
    })
}, h.destroy = function() {
    var b = this.internal;
    if (a.clearInterval(b.intervalForObserveInserted), void 0 !== b.resizeTimeout &amp;&amp; a.clearTimeout(b.resizeTimeout), a.detachEvent)
    a.detachEvent(&quot;onresize&quot;, b.resizeFunction);
    else if (a.removeEventListener)
    a.removeEventListener(&quot;resize&quot;, b.resizeFunction);
    else {
        var c = a.onresize;
        c &amp;&amp; c.add &amp;&amp; c.remove &amp;&amp; c.remove(b.resizeFunction)
    }
    return b.selectChart.classed(&quot;c3&quot;, !1).html(&quot;&quot;), Object.keys(b).forEach(function(a) {
        b[a] = null
    }), null
}, h.tooltip = function() {}, h.tooltip.show = function(a) {
    var b,
    c,
    d = this.internal;
    a.mouse &amp;&amp; (c = a.mouse), a.data ? d.isMultipleX() ? (c = [d.x(a.data.x), d.getYScale(a.data.id)(a.data.value)], b = null) : b = m(a.data.index) ? a.data.index : d.getIndexByX(a.data.x) : &quot;undefined&quot; != typeof a.x ? b = d.getIndexByX(a.x) : &quot;undefined&quot; != typeof a.index &amp;&amp; (b = a.index), d.dispatchEvent(&quot;mouseover&quot;, b, c), d.dispatchEvent(&quot;mousemove&quot;, b, c), d.config.tooltip_onshow.call(d, a.data)
}, h.tooltip.hide = function() {
    this.internal.dispatchEvent(&quot;mouseout&quot;, 0), this.internal.config.tooltip_onhide.call(this)
};
var A;
i.isSafari = function() {
    var b = a.navigator.userAgent;
    return b.indexOf(&quot;Safari&quot;) &gt;= 0 &amp;&amp; b.indexOf(&quot;Chrome&quot;) &lt; 0
}, i.isChrome = function() {
    var b = a.navigator.userAgent;
    return b.indexOf(&quot;Chrome&quot;) &gt;= 0
}, Function.prototype.bind || (Function.prototype.bind = function(a) {
    if (&quot;function&quot; != typeof this)
    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    var b = Array.prototype.slice.call(arguments, 1),
    c = this,
    d = function() {},
    e = function() {
        return c.apply(this instanceof d ? this : a, b.concat(Array.prototype.slice.call(arguments)))
    };
    return d.prototype = this.prototype, e.prototype = new d, e
}), function() {
    &quot;SVGPathSeg&quot; in a || (a.SVGPathSeg = function(a, b, c) {
        this.pathSegType = a, this.pathSegTypeAsLetter = b, this._owningPathSegList = c
    }, SVGPathSeg.PATHSEG_UNKNOWN = 0, SVGPathSeg.PATHSEG_CLOSEPATH = 1, SVGPathSeg.PATHSEG_MOVETO_ABS = 2, SVGPathSeg.PATHSEG_MOVETO_REL = 3, SVGPathSeg.PATHSEG_LINETO_ABS = 4, SVGPathSeg.PATHSEG_LINETO_REL = 5, SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6, SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9, SVGPathSeg.PATHSEG_ARC_ABS = 10, SVGPathSeg.PATHSEG_ARC_REL = 11, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13, SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14, SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19, SVGPathSeg.prototype._segmentChanged = function() {
        this._owningPathSegList &amp;&amp; this._owningPathSegList.segmentChanged(this)
    }, a.SVGPathSegClosePath = function(a) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CLOSEPATH, &quot;z&quot;, a)
    }, SVGPathSegClosePath.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegClosePath.prototype.toString = function() {
        return &quot;[object SVGPathSegClosePath]&quot;
    }, SVGPathSegClosePath.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter
    }, SVGPathSegClosePath.prototype.clone = function() {
        return new SVGPathSegClosePath(void 0)
    }, a.SVGPathSegMovetoAbs = function(a, b, c) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_ABS, &quot;M&quot;, a), this._x = b, this._y = c
    }, SVGPathSegMovetoAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegMovetoAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegMovetoAbs]&quot;
    }, SVGPathSegMovetoAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegMovetoAbs.prototype.clone = function() {
        return new SVGPathSegMovetoAbs(void 0, this._x, this._y)
    }, Object.defineProperty(SVGPathSegMovetoAbs.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegMovetoAbs.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegMovetoRel = function(a, b, c) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_REL, &quot;m&quot;, a), this._x = b, this._y = c
    }, SVGPathSegMovetoRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegMovetoRel.prototype.toString = function() {
        return &quot;[object SVGPathSegMovetoRel]&quot;
    }, SVGPathSegMovetoRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegMovetoRel.prototype.clone = function() {
        return new SVGPathSegMovetoRel(void 0, this._x, this._y)
    }, Object.defineProperty(SVGPathSegMovetoRel.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegMovetoRel.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegLinetoAbs = function(a, b, c) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_ABS, &quot;L&quot;, a), this._x = b, this._y = c
    }, SVGPathSegLinetoAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegLinetoAbs]&quot;
    }, SVGPathSegLinetoAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegLinetoAbs.prototype.clone = function() {
        return new SVGPathSegLinetoAbs(void 0, this._x, this._y)
    }, Object.defineProperty(SVGPathSegLinetoAbs.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegLinetoAbs.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegLinetoRel = function(a, b, c) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_REL, &quot;l&quot;, a), this._x = b, this._y = c
    }, SVGPathSegLinetoRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoRel.prototype.toString = function() {
        return &quot;[object SVGPathSegLinetoRel]&quot;
    }, SVGPathSegLinetoRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegLinetoRel.prototype.clone = function() {
        return new SVGPathSegLinetoRel(void 0, this._x, this._y)
    }, Object.defineProperty(SVGPathSegLinetoRel.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegLinetoRel.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegCurvetoCubicAbs = function(a, b, c, d, e, f, g) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, &quot;C&quot;, a), this._x = b, this._y = c, this._x1 = d, this._y1 = e, this._x2 = f, this._y2 = g
    }, SVGPathSegCurvetoCubicAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoCubicAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegCurvetoCubicAbs]&quot;
    }, SVGPathSegCurvetoCubicAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x1 + &quot; &quot; + this._y1 + &quot; &quot; + this._x2 + &quot; &quot; + this._y2 + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegCurvetoCubicAbs.prototype.clone = function() {
        return new SVGPathSegCurvetoCubicAbs(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2)
    }, Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, &quot;x1&quot;, {
        get: function() {
            return this._x1
        },
        set: function(a) {
            this._x1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, &quot;y1&quot;, {
        get: function() {
            return this._y1
        },
        set: function(a) {
            this._y1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, &quot;x2&quot;, {
        get: function() {
            return this._x2
        },
        set: function(a) {
            this._x2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, &quot;y2&quot;, {
        get: function() {
            return this._y2
        },
        set: function(a) {
            this._y2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegCurvetoCubicRel = function(a, b, c, d, e, f, g) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, &quot;c&quot;, a), this._x = b, this._y = c, this._x1 = d, this._y1 = e, this._x2 = f, this._y2 = g
    }, SVGPathSegCurvetoCubicRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoCubicRel.prototype.toString = function() {
        return &quot;[object SVGPathSegCurvetoCubicRel]&quot;
    }, SVGPathSegCurvetoCubicRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x1 + &quot; &quot; + this._y1 + &quot; &quot; + this._x2 + &quot; &quot; + this._y2 + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegCurvetoCubicRel.prototype.clone = function() {
        return new SVGPathSegCurvetoCubicRel(void 0, this._x, this._y, this._x1, this._y1, this._x2, this._y2)
    }, Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, &quot;x1&quot;, {
        get: function() {
            return this._x1
        },
        set: function(a) {
            this._x1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, &quot;y1&quot;, {
        get: function() {
            return this._y1
        },
        set: function(a) {
            this._y1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, &quot;x2&quot;, {
        get: function() {
            return this._x2
        },
        set: function(a) {
            this._x2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, &quot;y2&quot;, {
        get: function() {
            return this._y2
        },
        set: function(a) {
            this._y2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegCurvetoQuadraticAbs = function(a, b, c, d, e) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, &quot;Q&quot;, a), this._x = b, this._y = c, this._x1 = d, this._y1 = e
    }, SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoQuadraticAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegCurvetoQuadraticAbs]&quot;
    }, SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x1 + &quot; &quot; + this._y1 + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegCurvetoQuadraticAbs.prototype.clone = function() {
        return new SVGPathSegCurvetoQuadraticAbs(void 0, this._x, this._y, this._x1, this._y1)
    }, Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, &quot;x1&quot;, {
        get: function() {
            return this._x1
        },
        set: function(a) {
            this._x1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, &quot;y1&quot;, {
        get: function() {
            return this._y1
        },
        set: function(a) {
            this._y1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegCurvetoQuadraticRel = function(a, b, c, d, e) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, &quot;q&quot;, a), this._x = b, this._y = c, this._x1 = d, this._y1 = e
    }, SVGPathSegCurvetoQuadraticRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoQuadraticRel.prototype.toString = function() {
        return &quot;[object SVGPathSegCurvetoQuadraticRel]&quot;
    }, SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x1 + &quot; &quot; + this._y1 + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegCurvetoQuadraticRel.prototype.clone = function() {
        return new SVGPathSegCurvetoQuadraticRel(void 0, this._x, this._y, this._x1, this._y1)
    }, Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, &quot;x1&quot;, {
        get: function() {
            return this._x1
        },
        set: function(a) {
            this._x1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, &quot;y1&quot;, {
        get: function() {
            return this._y1
        },
        set: function(a) {
            this._y1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegArcAbs = function(a, b, c, d, e, f, g, h) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_ABS, &quot;A&quot;, a), this._x = b, this._y = c, this._r1 = d, this._r2 = e, this._angle = f, this._largeArcFlag = g, this._sweepFlag = h
    }, SVGPathSegArcAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegArcAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegArcAbs]&quot;
    }, SVGPathSegArcAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._r1 + &quot; &quot; + this._r2 + &quot; &quot; + this._angle + &quot; &quot; + (this._largeArcFlag ? &quot;1&quot; : &quot;0&quot;) + &quot; &quot; + (this._sweepFlag ? &quot;1&quot; : &quot;0&quot;) + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegArcAbs.prototype.clone = function() {
        return new SVGPathSegArcAbs(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag)
    }, Object.defineProperty(SVGPathSegArcAbs.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcAbs.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcAbs.prototype, &quot;r1&quot;, {
        get: function() {
            return this._r1
        },
        set: function(a) {
            this._r1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcAbs.prototype, &quot;r2&quot;, {
        get: function() {
            return this._r2
        },
        set: function(a) {
            this._r2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcAbs.prototype, &quot;angle&quot;, {
        get: function() {
            return this._angle
        },
        set: function(a) {
            this._angle = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcAbs.prototype, &quot;largeArcFlag&quot;, {
        get: function() {
            return this._largeArcFlag
        },
        set: function(a) {
            this._largeArcFlag = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcAbs.prototype, &quot;sweepFlag&quot;, {
        get: function() {
            return this._sweepFlag
        },
        set: function(a) {
            this._sweepFlag = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegArcRel = function(a, b, c, d, e, f, g, h) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_REL, &quot;a&quot;, a), this._x = b, this._y = c, this._r1 = d, this._r2 = e, this._angle = f, this._largeArcFlag = g, this._sweepFlag = h
    }, SVGPathSegArcRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegArcRel.prototype.toString = function() {
        return &quot;[object SVGPathSegArcRel]&quot;
    }, SVGPathSegArcRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._r1 + &quot; &quot; + this._r2 + &quot; &quot; + this._angle + &quot; &quot; + (this._largeArcFlag ? &quot;1&quot; : &quot;0&quot;) + &quot; &quot; + (this._sweepFlag ? &quot;1&quot; : &quot;0&quot;) + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegArcRel.prototype.clone = function() {
        return new SVGPathSegArcRel(void 0, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag)
    }, Object.defineProperty(SVGPathSegArcRel.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcRel.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcRel.prototype, &quot;r1&quot;, {
        get: function() {
            return this._r1
        },
        set: function(a) {
            this._r1 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcRel.prototype, &quot;r2&quot;, {
        get: function() {
            return this._r2
        },
        set: function(a) {
            this._r2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcRel.prototype, &quot;angle&quot;, {
        get: function() {
            return this._angle
        },
        set: function(a) {
            this._angle = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcRel.prototype, &quot;largeArcFlag&quot;, {
        get: function() {
            return this._largeArcFlag
        },
        set: function(a) {
            this._largeArcFlag = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegArcRel.prototype, &quot;sweepFlag&quot;, {
        get: function() {
            return this._sweepFlag
        },
        set: function(a) {
            this._sweepFlag = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegLinetoHorizontalAbs = function(a, b) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, &quot;H&quot;, a), this._x = b
    }, SVGPathSegLinetoHorizontalAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoHorizontalAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegLinetoHorizontalAbs]&quot;
    }, SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x
    }, SVGPathSegLinetoHorizontalAbs.prototype.clone = function() {
        return new SVGPathSegLinetoHorizontalAbs(void 0, this._x)
    }, Object.defineProperty(SVGPathSegLinetoHorizontalAbs.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegLinetoHorizontalRel = function(a, b) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, &quot;h&quot;, a), this._x = b
    }, SVGPathSegLinetoHorizontalRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoHorizontalRel.prototype.toString = function() {
        return &quot;[object SVGPathSegLinetoHorizontalRel]&quot;
    }, SVGPathSegLinetoHorizontalRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x
    }, SVGPathSegLinetoHorizontalRel.prototype.clone = function() {
        return new SVGPathSegLinetoHorizontalRel(void 0, this._x)
    }, Object.defineProperty(SVGPathSegLinetoHorizontalRel.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegLinetoVerticalAbs = function(a, b) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, &quot;V&quot;, a), this._y = b
    }, SVGPathSegLinetoVerticalAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoVerticalAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegLinetoVerticalAbs]&quot;
    }, SVGPathSegLinetoVerticalAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._y
    }, SVGPathSegLinetoVerticalAbs.prototype.clone = function() {
        return new SVGPathSegLinetoVerticalAbs(void 0, this._y)
    }, Object.defineProperty(SVGPathSegLinetoVerticalAbs.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegLinetoVerticalRel = function(a, b) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, &quot;v&quot;, a), this._y = b
    }, SVGPathSegLinetoVerticalRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegLinetoVerticalRel.prototype.toString = function() {
        return &quot;[object SVGPathSegLinetoVerticalRel]&quot;
    }, SVGPathSegLinetoVerticalRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._y
    }, SVGPathSegLinetoVerticalRel.prototype.clone = function() {
        return new SVGPathSegLinetoVerticalRel(void 0, this._y)
    }, Object.defineProperty(SVGPathSegLinetoVerticalRel.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegCurvetoCubicSmoothAbs = function(a, b, c, d, e) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, &quot;S&quot;, a), this._x = b, this._y = c, this._x2 = d, this._y2 = e
    }, SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegCurvetoCubicSmoothAbs]&quot;
    }, SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x2 + &quot; &quot; + this._y2 + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function() {
        return new SVGPathSegCurvetoCubicSmoothAbs(void 0, this._x, this._y, this._x2, this._y2)
    }, Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, &quot;x2&quot;, {
        get: function() {
            return this._x2
        },
        set: function(a) {
            this._x2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, &quot;y2&quot;, {
        get: function() {
            return this._y2
        },
        set: function(a) {
            this._y2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegCurvetoCubicSmoothRel = function(a, b, c, d, e) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, &quot;s&quot;, a), this._x = b, this._y = c, this._x2 = d, this._y2 = e
    }, SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function() {
        return &quot;[object SVGPathSegCurvetoCubicSmoothRel]&quot;
    }, SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x2 + &quot; &quot; + this._y2 + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function() {
        return new SVGPathSegCurvetoCubicSmoothRel(void 0, this._x, this._y, this._x2, this._y2)
    }, Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, &quot;x2&quot;, {
        get: function() {
            return this._x2
        },
        set: function(a) {
            this._x2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, &quot;y2&quot;, {
        get: function() {
            return this._y2
        },
        set: function(a) {
            this._y2 = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegCurvetoQuadraticSmoothAbs = function(a, b, c) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, &quot;T&quot;, a), this._x = b, this._y = c
    }, SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function() {
        return &quot;[object SVGPathSegCurvetoQuadraticSmoothAbs]&quot;
    }, SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function() {
        return new SVGPathSegCurvetoQuadraticSmoothAbs(void 0, this._x, this._y)
    }, Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), a.SVGPathSegCurvetoQuadraticSmoothRel = function(a, b, c) {
        SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, &quot;t&quot;, a), this._x = b, this._y = c
    }, SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(SVGPathSeg.prototype), SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function() {
        return &quot;[object SVGPathSegCurvetoQuadraticSmoothRel]&quot;
    }, SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function() {
        return this.pathSegTypeAsLetter + &quot; &quot; + this._x + &quot; &quot; + this._y
    }, SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function() {
        return new SVGPathSegCurvetoQuadraticSmoothRel(void 0, this._x, this._y)
    }, Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, &quot;x&quot;, {
        get: function() {
            return this._x
        },
        set: function(a) {
            this._x = a, this._segmentChanged()
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, &quot;y&quot;, {
        get: function() {
            return this._y
        },
        set: function(a) {
            this._y = a, this._segmentChanged()
        },
        enumerable: !0
    }), SVGPathElement.prototype.createSVGPathSegClosePath = function() {
        return new SVGPathSegClosePath(void 0)
    }, SVGPathElement.prototype.createSVGPathSegMovetoAbs = function(a, b) {
        return new SVGPathSegMovetoAbs(void 0, a, b)
    }, SVGPathElement.prototype.createSVGPathSegMovetoRel = function(a, b) {
        return new SVGPathSegMovetoRel(void 0, a, b)
    }, SVGPathElement.prototype.createSVGPathSegLinetoAbs = function(a, b) {
        return new SVGPathSegLinetoAbs(void 0, a, b)
    }, SVGPathElement.prototype.createSVGPathSegLinetoRel = function(a, b) {
        return new SVGPathSegLinetoRel(void 0, a, b)
    }, SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function(a, b, c, d, e, f) {
        return new SVGPathSegCurvetoCubicAbs(void 0, a, b, c, d, e, f)
    }, SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function(a, b, c, d, e, f) {
        return new SVGPathSegCurvetoCubicRel(void 0, a, b, c, d, e, f)
    }, SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function(a, b, c, d) {
        return new SVGPathSegCurvetoQuadraticAbs(void 0, a, b, c, d)
    }, SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function(a, b, c, d) {
        return new SVGPathSegCurvetoQuadraticRel(void 0, a, b, c, d)
    }, SVGPathElement.prototype.createSVGPathSegArcAbs = function(a, b, c, d, e, f, g) {
        return new SVGPathSegArcAbs(void 0, a, b, c, d, e, f, g)
    }, SVGPathElement.prototype.createSVGPathSegArcRel = function(a, b, c, d, e, f, g) {
        return new SVGPathSegArcRel(void 0, a, b, c, d, e, f, g)
    }, SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function(a) {
        return new SVGPathSegLinetoHorizontalAbs(void 0, a)
    }, SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function(a) {
        return new SVGPathSegLinetoHorizontalRel(void 0, a)
    }, SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function(a) {
        return new SVGPathSegLinetoVerticalAbs(void 0, a)
    }, SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function(a) {
        return new SVGPathSegLinetoVerticalRel(void 0, a)
    }, SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function(a, b, c, d) {
        return new SVGPathSegCurvetoCubicSmoothAbs(void 0, a, b, c, d)
    }, SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function(a, b, c, d) {
        return new SVGPathSegCurvetoCubicSmoothRel(void 0, a, b, c, d)
    }, SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function(a, b) {
        return new SVGPathSegCurvetoQuadraticSmoothAbs(void 0, a, b)
    }, SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function(a, b) {
        return new SVGPathSegCurvetoQuadraticSmoothRel(void 0, a, b)
    }), &quot;SVGPathSegList&quot; in a || (a.SVGPathSegList = function(a) {
        this._pathElement = a, this._list = this._parsePath(this._pathElement.getAttribute(&quot;d&quot;)), this._mutationObserverConfig = {
            attributes: !0,
            attributeFilter: [&quot;d&quot;]
        }, this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this)), this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig)
    }, Object.defineProperty(SVGPathSegList.prototype, &quot;numberOfItems&quot;, {
        get: function() {
            return this._checkPathSynchronizedToList(), this._list.length
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathElement.prototype, &quot;pathSegList&quot;, {
        get: function() {
            return this._pathSegList || (this._pathSegList = new SVGPathSegList(this)), this._pathSegList
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathElement.prototype, &quot;normalizedPathSegList&quot;, {
        get: function() {
            return this.pathSegList
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathElement.prototype, &quot;animatedPathSegList&quot;, {
        get: function() {
            return this.pathSegList
        },
        enumerable: !0
    }), Object.defineProperty(SVGPathElement.prototype, &quot;animatedNormalizedPathSegList&quot;, {
        get: function() {
            return this.pathSegList
        },
        enumerable: !0
    }), SVGPathSegList.prototype._checkPathSynchronizedToList = function() {
        this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords())
    }, SVGPathSegList.prototype._updateListFromPathMutations = function(a) {
        if (this._pathElement) {
            var b = !1;
            a.forEach(function(a) {
                &quot;d&quot; == a.attributeName &amp;&amp; (b = !0)
            }), b &amp;&amp; (this._list = this._parsePath(this._pathElement.getAttribute(&quot;d&quot;)))
        }
    }, SVGPathSegList.prototype._writeListToPath = function() {
        this._pathElementMutationObserver.disconnect(), this._pathElement.setAttribute(&quot;d&quot;, SVGPathSegList._pathSegArrayAsString(this._list)), this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig)
    }, SVGPathSegList.prototype.segmentChanged = function(a) {
        this._writeListToPath()
    }, SVGPathSegList.prototype.clear = function() {
        this._checkPathSynchronizedToList(), this._list.forEach(function(a) {
            a._owningPathSegList = null
        }), this._list = [], this._writeListToPath()
    }, SVGPathSegList.prototype.initialize = function(a) {
        return this._checkPathSynchronizedToList(), this._list = [a], a._owningPathSegList = this, this._writeListToPath(), a
    }, SVGPathSegList.prototype._checkValidIndex = function(a) {
        if (isNaN(a) || 0 &gt; a || a &gt;= this.numberOfItems)
        throw &quot;INDEX_SIZE_ERR&quot;
    }, SVGPathSegList.prototype.getItem = function(a) {
        return this._checkPathSynchronizedToList(), this._checkValidIndex(a), this._list[a]
    }, SVGPathSegList.prototype.insertItemBefore = function(a, b) {
        return this._checkPathSynchronizedToList(), b &gt; this.numberOfItems &amp;&amp; (b = this.numberOfItems), a._owningPathSegList &amp;&amp; (a = a.clone()), this._list.splice(b, 0, a), a._owningPathSegList = this, this._writeListToPath(), a
    }, SVGPathSegList.prototype.replaceItem = function(a, b) {
        return this._checkPathSynchronizedToList(), a._owningPathSegList &amp;&amp; (a = a.clone()), this._checkValidIndex(b), this._list[b] = a, a._owningPathSegList = this, this._writeListToPath(), a
    }, SVGPathSegList.prototype.removeItem = function(a) {
        this._checkPathSynchronizedToList(), this._checkValidIndex(a);
        var b = this._list[a];
        return this._list.splice(a, 1), this._writeListToPath(), b
    }, SVGPathSegList.prototype.appendItem = function(a) {
        return this._checkPathSynchronizedToList(), a._owningPathSegList &amp;&amp; (a = a.clone()), this._list.push(a), a._owningPathSegList = this, this._writeListToPath(), a
    }, SVGPathSegList._pathSegArrayAsString = function(a) {
        var b = &quot;&quot;,
        c = !0;
        return a.forEach(function(a) {
            c ? (c = !1, b += a._asPathString()) : b += &quot; &quot; + a._asPathString()
        }), b
    }, SVGPathSegList.prototype._parsePath = function(a) {
        if (!a || 0 == a.length)
        return [];
        var b = this,
        c = function() {
            this.pathSegList = []
        };
        c.prototype.appendSegment = function(a) {
            this.pathSegList.push(a)
        };
        var d = function(a) {
            this._string = a, this._currentIndex = 0, this._endIndex = this._string.length, this._previousCommand = SVGPathSeg.PATHSEG_UNKNOWN, this._skipOptionalSpaces()
        };
        d.prototype._isCurrentSpace = function() {
            var a = this._string[this._currentIndex];
            return &quot; &quot; &gt;= a &amp;&amp; (&quot; &quot; == a || &quot;\n&quot; == a || &quot;  &quot; == a || &quot;\r&quot; == a || &quot;\f&quot; == a)
        }, d.prototype._skipOptionalSpaces = function() {
            for (; this._currentIndex &lt; this._endIndex &amp;&amp; this._isCurrentSpace();)
            this._currentIndex++;
            return this._currentIndex &lt; this._endIndex
        }, d.prototype._skipOptionalSpacesOrDelimiter = function() {
            return this._currentIndex &lt; this._endIndex &amp;&amp; !this._isCurrentSpace() &amp;&amp; &quot;,&quot; != this._string.charAt(this._currentIndex) ? !1 : (this._skipOptionalSpaces() &amp;&amp; this._currentIndex &lt; this._endIndex &amp;&amp; &quot;,&quot; == this._string.charAt(this._currentIndex) &amp;&amp; (this._currentIndex++, this._skipOptionalSpaces()), this._currentIndex &lt; this._endIndex)
        }, d.prototype.hasMoreData = function() {
            return this._currentIndex &lt; this._endIndex
        }, d.prototype.peekSegmentType = function() {
            var a = this._string[this._currentIndex];
            return this._pathSegTypeFromChar(a)
        }, d.prototype._pathSegTypeFromChar = function(a) {
            switch (a) {
                case &quot;Z&quot;:
                case &quot;z&quot;:
                return SVGPathSeg.PATHSEG_CLOSEPATH;
                case &quot;M&quot;:
                return SVGPathSeg.PATHSEG_MOVETO_ABS;
                case &quot;m&quot;:
                return SVGPathSeg.PATHSEG_MOVETO_REL;
                case &quot;L&quot;:
                return SVGPathSeg.PATHSEG_LINETO_ABS;
                case &quot;l&quot;:
                return SVGPathSeg.PATHSEG_LINETO_REL;
                case &quot;C&quot;:
                return SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;
                case &quot;c&quot;:
                return SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
                case &quot;Q&quot;:
                return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;
                case &quot;q&quot;:
                return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;
                case &quot;A&quot;:
                return SVGPathSeg.PATHSEG_ARC_ABS;
                case &quot;a&quot;:
                return SVGPathSeg.PATHSEG_ARC_REL;
                case &quot;H&quot;:
                return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;
                case &quot;h&quot;:
                return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;
                case &quot;V&quot;:
                return SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;
                case &quot;v&quot;:
                return SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;
                case &quot;S&quot;:
                return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
                case &quot;s&quot;:
                return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
                case &quot;T&quot;:
                return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
                case &quot;t&quot;:
                return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
                default:
                return SVGPathSeg.PATHSEG_UNKNOWN
            }
        }, d.prototype._nextCommandHelper = function(a, b) {
            return (&quot;+&quot; == a || &quot;-&quot; == a || &quot;.&quot; == a || a &gt;= &quot;0&quot; &amp;&amp; &quot;9&quot; &gt;= a) &amp;&amp; b != SVGPathSeg.PATHSEG_CLOSEPATH ? b == SVGPathSeg.PATHSEG_MOVETO_ABS ? SVGPathSeg.PATHSEG_LINETO_ABS : b == SVGPathSeg.PATHSEG_MOVETO_REL ? SVGPathSeg.PATHSEG_LINETO_REL : b : SVGPathSeg.PATHSEG_UNKNOWN
        }, d.prototype.initialCommandIsMoveTo = function() {
            if (!this.hasMoreData())
            return !0;
            var a = this.peekSegmentType();
            return a == SVGPathSeg.PATHSEG_MOVETO_ABS || a == SVGPathSeg.PATHSEG_MOVETO_REL
        }, d.prototype._parseNumber = function() {
            var a = 0,
            b = 0,
            c = 1,
            d = 0,
            e = 1,
            f = 1,
            g = this._currentIndex;
            if (this._skipOptionalSpaces(), this._currentIndex &lt; this._endIndex &amp;&amp; &quot;+&quot; == this._string.charAt(this._currentIndex) ? this._currentIndex++ : this._currentIndex &lt; this._endIndex &amp;&amp; &quot;-&quot; == this._string.charAt(this._currentIndex) &amp;&amp; (this._currentIndex++, e = -1), !(this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) &lt; &quot;0&quot; || this._string.charAt(this._currentIndex) &gt; &quot;9&quot;) &amp;&amp; &quot;.&quot; != this._string.charAt(this._currentIndex))) {
                for (var h = this._currentIndex; this._currentIndex &lt; this._endIndex &amp;&amp; this._string.charAt(this._currentIndex) &gt;= &quot;0&quot; &amp;&amp; this._string.charAt(this._currentIndex) &lt;= &quot;9&quot;;)
                this._currentIndex++;
                if (this._currentIndex != h)
                for (var i = this._currentIndex - 1, j = 1; i &gt;= h;)
                b += j * (this._string.charAt(i--) - &quot;0&quot;), j *= 10;
                if (this._currentIndex &lt; this._endIndex &amp;&amp; &quot;.&quot; == this._string.charAt(this._currentIndex)) {
                    if (this._currentIndex++, this._currentIndex &gt;= this._endIndex || this._string.charAt(this._currentIndex) &lt; &quot;0&quot; || this._string.charAt(this._currentIndex) &gt; &quot;9&quot;)
                    return;
                    for (; this._currentIndex &lt; this._endIndex &amp;&amp; this._string.charAt(this._currentIndex) &gt;= &quot;0&quot; &amp;&amp; this._string.charAt(this._currentIndex) &lt;= &quot;9&quot;;)
                    d += (this._string.charAt(this._currentIndex++) - &quot;0&quot;) * (c *= .1)
                }
                if (this._currentIndex != g &amp;&amp; this._currentIndex + 1 &lt; this._endIndex &amp;&amp; (&quot;e&quot; == this._string.charAt(this._currentIndex) || &quot;E&quot; == this._string.charAt(this._currentIndex)) &amp;&amp; &quot;x&quot; != this._string.charAt(this._currentIndex + 1) &amp;&amp; &quot;m&quot; != this._string.charAt(this._currentIndex + 1)) {
                    if (this._currentIndex++, &quot;+&quot; == this._string.charAt(this._currentIndex) ? this._currentIndex++ : &quot;-&quot; == this._string.charAt(this._currentIndex) &amp;&amp; (this._currentIndex++, f = -1), this._currentIndex &gt;= this._endIndex || this._string.charAt(this._currentIndex) &lt; &quot;0&quot; || this._string.charAt(this._currentIndex) &gt; &quot;9&quot;)
                    return;
                    for (; this._currentIndex &lt; this._endIndex &amp;&amp; this._string.charAt(this._currentIndex) &gt;= &quot;0&quot; &amp;&amp; this._string.charAt(this._currentIndex) &lt;= &quot;9&quot;;)
                    a *= 10, a += this._string.charAt(this._currentIndex) - &quot;0&quot;, this._currentIndex++
                }
                var k = b + d;
                if (k *= e, a &amp;&amp; (k *= Math.pow(10, f * a)), g != this._currentIndex)
                return this._skipOptionalSpacesOrDelimiter(), k
            }
        }, d.prototype._parseArcFlag = function() {
            if (!(this._currentIndex &gt;= this._endIndex)) {
                var a = !1,
                b = this._string.charAt(this._currentIndex++);
                if (&quot;0&quot; == b)
                a = !1;
                else {
                    if (&quot;1&quot; != b)
                    return;
                    a = !0
                }
                return this._skipOptionalSpacesOrDelimiter(), a
            }
        }, d.prototype.parseSegment = function() {
            var a = this._string[this._currentIndex],
            c = this._pathSegTypeFromChar(a);
            if (c == SVGPathSeg.PATHSEG_UNKNOWN) {
                if (this._previousCommand == SVGPathSeg.PATHSEG_UNKNOWN)
                return null;
                if (c = this._nextCommandHelper(a, this._previousCommand), c == SVGPathSeg.PATHSEG_UNKNOWN)
                return null
            } else
            this._currentIndex++;
            switch (this._previousCommand = c, c) {
                case SVGPathSeg.PATHSEG_MOVETO_REL:
                return new SVGPathSegMovetoRel(b, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                return new SVGPathSegMovetoAbs(b, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_REL:
                return new SVGPathSegLinetoRel(b, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_ABS:
                return new SVGPathSegLinetoAbs(b, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                return new SVGPathSegLinetoHorizontalRel(b, this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                return new SVGPathSegLinetoHorizontalAbs(b, this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                return new SVGPathSegLinetoVerticalRel(b, this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                return new SVGPathSegLinetoVerticalAbs(b, this._parseNumber());
                case SVGPathSeg.PATHSEG_CLOSEPATH:
                return this._skipOptionalSpaces(), new SVGPathSegClosePath(b);
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                var d = {
                    x1: this._parseNumber(),
                    y1: this._parseNumber(),
                    x2: this._parseNumber(),
                    y2: this._parseNumber(),
                    x: this._parseNumber(),
                    y: this._parseNumber()
                };
                return new SVGPathSegCurvetoCubicRel(b, d.x, d.y, d.x1, d.y1, d.x2, d.y2);
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                var d = {
                    x1: this._parseNumber(),
                    y1: this._parseNumber(),
                    x2: this._parseNumber(),
                    y2: this._parseNumber(),
                    x: this._parseNumber(),
                    y: this._parseNumber()
                };
                return new SVGPathSegCurvetoCubicAbs(b, d.x, d.y, d.x1, d.y1, d.x2, d.y2);
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                var d = {
                    x2: this._parseNumber(),
                    y2: this._parseNumber(),
                    x: this._parseNumber(),
                    y: this._parseNumber()
                };
                return new SVGPathSegCurvetoCubicSmoothRel(b, d.x, d.y, d.x2, d.y2);
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                var d = {
                    x2: this._parseNumber(),
                    y2: this._parseNumber(),
                    x: this._parseNumber(),
                    y: this._parseNumber()
                };
                return new SVGPathSegCurvetoCubicSmoothAbs(b, d.x, d.y, d.x2, d.y2);
                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                var d = {
                    x1: this._parseNumber(),
                    y1: this._parseNumber(),
                    x: this._parseNumber(),
                    y: this._parseNumber()
                };
                return new SVGPathSegCurvetoQuadraticRel(b, d.x, d.y, d.x1, d.y1);
                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                var d = {
                    x1: this._parseNumber(),
                    y1: this._parseNumber(),
                    x: this._parseNumber(),
                    y: this._parseNumber()
                };
                return new SVGPathSegCurvetoQuadraticAbs(b, d.x, d.y, d.x1, d.y1);
                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
                return new SVGPathSegCurvetoQuadraticSmoothRel(b, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
                return new SVGPathSegCurvetoQuadraticSmoothAbs(b, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_ARC_REL:
                var d = {
                    x1: this._parseNumber(),
                    y1: this._parseNumber(),
                    arcAngle: this._parseNumber(),
                    arcLarge: this._parseArcFlag(),
                    arcSweep: this._parseArcFlag(),
                    x: this._parseNumber(),
                    y: this._parseNumber()
                };
                return new SVGPathSegArcRel(b, d.x, d.y, d.x1, d.y1, d.arcAngle, d.arcLarge, d.arcSweep);
                case SVGPathSeg.PATHSEG_ARC_ABS:
                var d = {
                    x1: this._parseNumber(),
                    y1: this._parseNumber(),
                    arcAngle: this._parseNumber(),
                    arcLarge: this._parseArcFlag(),
                    arcSweep: this._parseArcFlag(),
                    x: this._parseNumber(),
                    y: this._parseNumber()
                };
                return new SVGPathSegArcAbs(b, d.x, d.y, d.x1, d.y1, d.arcAngle, d.arcLarge, d.arcSweep);
                default:
                throw &quot;Unknown path seg type.&quot;
            }
        };
        var e = new c,
        f = new d(a);
        if (!f.initialCommandIsMoveTo())
        return [];
        for (; f.hasMoreData();) {
            var g = f.parseSegment();
            if (!g)
            return [];
            e.appendSegment(g)
        }
        return e.pathSegList
    })
}(), &quot;function&quot; == typeof define &amp;&amp; define.amd ? define(&quot;c3&quot;, [&quot;d3&quot;], function() {
    return k
}) : &quot;undefined&quot; != typeof exports &amp;&amp; &quot;undefined&quot; != typeof module ? module.exports = k : a.c3 = k</pre>

<p>}(window);</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.3.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

